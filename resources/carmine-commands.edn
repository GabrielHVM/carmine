{
"ACL" {:fn-name "acl", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["ACL"], :fn-docstring "A container for Access List Control commands .\n\nACL \n\nAvailable since: 6.0.0.\n\nTime complexity: Depends on subcommand."}
"ACL CAT" {:fn-name "acl-cat", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["ACL" "CAT"], :fn-docstring "List the ACL categories or the commands inside a category.\n\nACL CAT [categoryname]\n\nAvailable since: 6.0.0.\n\nTime complexity: O(1) since the categories and commands are a fixed set."}
"ACL DELUSER" {:fn-name "acl-deluser", :cluster-key-idx 2, :fn-params-more [username & args], :fn-params-fixed [username], :req-args-fixed ["ACL" "DELUSER" username], :fn-docstring "Remove the specified ACL users and the associated rules.\n\nACL DELUSER username [username ...]\n\nAvailable since: 6.0.0.\n\nTime complexity: O(1) amortized time considering the typical user."}
"ACL DRYRUN" {:fn-name "acl-dryrun", :cluster-key-idx 2, :fn-params-more [username command & args], :fn-params-fixed [username command], :req-args-fixed ["ACL" "DRYRUN" username command], :fn-docstring "Returns whether the user can execute the given command without executing the command..\n\nACL DRYRUN username command [arg [arg ...]]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(1)."}
"ACL GENPASS" {:fn-name "acl-genpass", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["ACL" "GENPASS"], :fn-docstring "Generate a pseudorandom secure password to use for ACL users.\n\nACL GENPASS [bits]\n\nAvailable since: 6.0.0.\n\nTime complexity: O(1)"}
"ACL GETUSER" {:fn-name "acl-getuser", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [username], :req-args-fixed ["ACL" "GETUSER" username], :fn-docstring "Get the rules for a specific ACL user.\n\nACL GETUSER username\n\nAvailable since: 6.0.0.\n\nTime complexity: O(N). Where N is the number of password, command and pattern rules that the user has."}
"ACL HELP" {:fn-name "acl-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["ACL" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nACL HELP \n\nAvailable since: 6.0.0.\n\nTime complexity: O(1)"}
"ACL LIST" {:fn-name "acl-list", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["ACL" "LIST"], :fn-docstring "List the current ACL rules in ACL config file format.\n\nACL LIST \n\nAvailable since: 6.0.0.\n\nTime complexity: O(N). Where N is the number of configured users."}
"ACL LOAD" {:fn-name "acl-load", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["ACL" "LOAD"], :fn-docstring "Reload the ACLs from the configured ACL file.\n\nACL LOAD \n\nAvailable since: 6.0.0.\n\nTime complexity: O(N). Where N is the number of configured users."}
"ACL LOG" {:fn-name "acl-log", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["ACL" "LOG"], :fn-docstring "List latest events denied because of ACLs in place.\n\nACL LOG [operation]\n\nAvailable since: 6.0.0.\n\nTime complexity: O(N) with N being the number of entries shown."}
"ACL SAVE" {:fn-name "acl-save", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["ACL" "SAVE"], :fn-docstring "Save the current ACL rules in the configured ACL file.\n\nACL SAVE \n\nAvailable since: 6.0.0.\n\nTime complexity: O(N). Where N is the number of configured users."}
"ACL SETUSER" {:fn-name "acl-setuser", :cluster-key-idx 2, :fn-params-more [username & args], :fn-params-fixed [username], :req-args-fixed ["ACL" "SETUSER" username], :fn-docstring "Modify or create the rules for a specific ACL user.\n\nACL SETUSER username [rule [rule ...]]\n\nAvailable since: 6.0.0.\n\nTime complexity: O(N). Where N is the number of rules provided."}
"ACL USERS" {:fn-name "acl-users", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["ACL" "USERS"], :fn-docstring "List the username of all the configured ACL rules.\n\nACL USERS \n\nAvailable since: 6.0.0.\n\nTime complexity: O(N). Where N is the number of configured users."}
"ACL WHOAMI" {:fn-name "acl-whoami", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["ACL" "WHOAMI"], :fn-docstring "Return the name of the user associated to the current connection.\n\nACL WHOAMI \n\nAvailable since: 6.0.0.\n\nTime complexity: O(1)"}
"APPEND" {:fn-name "append", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key value], :req-args-fixed ["APPEND" key value], :fn-docstring "Append a value to a key.\n\nAPPEND key value\n\nAvailable since: 2.0.0.\n\nTime complexity: O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation."}
"ASKING" {:fn-name "asking", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["ASKING"], :fn-docstring "Sent by cluster clients after an -ASK redirect.\n\nASKING \n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"AUTH" {:fn-name "auth", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["AUTH"], :fn-docstring "Authenticate to the server.\n\nAUTH [username] password\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of passwords defined for the user"}
"BGREWRITEAOF" {:fn-name "bgrewriteaof", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["BGREWRITEAOF"], :fn-docstring "Asynchronously rewrite the append-only file.\n\nBGREWRITEAOF \n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"BGSAVE" {:fn-name "bgsave", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["BGSAVE"], :fn-docstring "Asynchronously save the dataset to disk.\n\nBGSAVE [schedule]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"BITCOUNT" {:fn-name "bitcount", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["BITCOUNT" key], :fn-docstring "Count set bits in a string.\n\nBITCOUNT key [index]\n\nAvailable since: 2.6.0.\n\nTime complexity: O(N)"}
"BITFIELD" {:fn-name "bitfield", :cluster-key-idx 1, :fn-params-more [key operation & args], :fn-params-fixed [key operation], :req-args-fixed ["BITFIELD" key operation], :fn-docstring "Perform arbitrary bitfield integer operations on strings.\n\nBITFIELD key operation [operation ...]\n\nAvailable since: 3.2.0.\n\nTime complexity: O(1) for each subcommand specified"}
"BITFIELD_RO" {:fn-name "bitfield_ro", :cluster-key-idx 1, :fn-params-more [key encoding_offset & args], :fn-params-fixed [key encoding_offset], :req-args-fixed ["BITFIELD_RO" key encoding_offset], :fn-docstring "Perform arbitrary bitfield integer operations on strings. Read-only variant of BITFIELD.\n\nBITFIELD_RO key encoding_offset [encoding_offset ...]\n\nAvailable since: 6.0.0.\n\nTime complexity: O(1) for each subcommand specified"}
"BITOP" {:fn-name "bitop", :cluster-key-idx 1, :fn-params-more [operation destkey key & args], :fn-params-fixed [operation destkey key], :req-args-fixed ["BITOP" operation destkey key], :fn-docstring "Perform bitwise operations between strings.\n\nBITOP operation destkey key [key ...]\n\nAvailable since: 2.6.0.\n\nTime complexity: O(N)"}
"BITPOS" {:fn-name "bitpos", :cluster-key-idx 1, :fn-params-more [key bit & args], :fn-params-fixed [key bit], :req-args-fixed ["BITPOS" key bit], :fn-docstring "Find first bit set or clear in a string.\n\nBITPOS key bit [index]\n\nAvailable since: 2.8.7.\n\nTime complexity: O(N)"}
"BLMOVE" {:fn-name "blmove", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [source destination wherefrom whereto timeout], :req-args-fixed ["BLMOVE" source destination wherefrom whereto timeout], :fn-docstring "Pop an element from a list, push it to another list and return it; or block until one is available.\n\nBLMOVE source destination wherefrom whereto timeout\n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"BLMPOP" {:fn-name "blmpop", :cluster-key-idx 1, :fn-params-more [timeout numkeys key & args], :fn-params-fixed [timeout numkeys key], :req-args-fixed ["BLMPOP" timeout numkeys key], :fn-docstring "Pop elements from a list, or block until one is available.\n\nBLMPOP timeout numkeys key [key ...] where [count]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N+M) where N is the number of provided keys and M is the number of elements returned."}
"BLPOP" {:fn-name "blpop", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["BLPOP" key], :fn-docstring "Remove and get the first element in a list, or block until one is available.\n\nBLPOP key [key ...] timeout\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the number of provided keys."}
"BRPOP" {:fn-name "brpop", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["BRPOP" key], :fn-docstring "Remove and get the last element in a list, or block until one is available.\n\nBRPOP key [key ...] timeout\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the number of provided keys."}
"BRPOPLPUSH" {:fn-name "brpoplpush", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [source destination timeout], :req-args-fixed ["BRPOPLPUSH" source destination timeout], :fn-docstring "Pop an element from a list, push it to another list and return it; or block until one is available.\n\nBRPOPLPUSH source destination timeout\n\nAvailable since: 2.2.0.\n\nTime complexity: O(1)"}
"BZMPOP" {:fn-name "bzmpop", :cluster-key-idx 1, :fn-params-more [timeout numkeys key & args], :fn-params-fixed [timeout numkeys key], :req-args-fixed ["BZMPOP" timeout numkeys key], :fn-docstring "Remove and return members with scores in a sorted set or block until one is available.\n\nBZMPOP timeout numkeys key [key ...] where [count]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(K) + O(N*log(M)) where K is the number of provided keys, N being the number of elements in the sorted set, and M being the number of elements popped."}
"BZPOPMAX" {:fn-name "bzpopmax", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["BZPOPMAX" key], :fn-docstring "Remove and return the member with the highest score from one or more sorted sets, or block until one is available.\n\nBZPOPMAX key [key ...] timeout\n\nAvailable since: 5.0.0.\n\nTime complexity: O(log(N)) with N being the number of elements in the sorted set."}
"BZPOPMIN" {:fn-name "bzpopmin", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["BZPOPMIN" key], :fn-docstring "Remove and return the member with the lowest score from one or more sorted sets, or block until one is available.\n\nBZPOPMIN key [key ...] timeout\n\nAvailable since: 5.0.0.\n\nTime complexity: O(log(N)) with N being the number of elements in the sorted set."}
"CLIENT" {:fn-name "client", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLIENT"], :fn-docstring "A container for client connection commands.\n\nCLIENT \n\nAvailable since: 2.4.0.\n\nTime complexity: Depends on subcommand."}
"CLIENT CACHING" {:fn-name "client-caching", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [mode], :req-args-fixed ["CLIENT" "CACHING" mode], :fn-docstring "Instruct the server about tracking or not keys in the next request.\n\nCLIENT CACHING mode\n\nAvailable since: 6.0.0.\n\nTime complexity: O(1)"}
"CLIENT GETNAME" {:fn-name "client-getname", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLIENT" "GETNAME"], :fn-docstring "Get the current connection name.\n\nCLIENT GETNAME \n\nAvailable since: 2.6.9.\n\nTime complexity: O(1)"}
"CLIENT GETREDIR" {:fn-name "client-getredir", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLIENT" "GETREDIR"], :fn-docstring "Get tracking notifications redirection client ID if any.\n\nCLIENT GETREDIR \n\nAvailable since: 6.0.0.\n\nTime complexity: O(1)"}
"CLIENT HELP" {:fn-name "client-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLIENT" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nCLIENT HELP \n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"CLIENT ID" {:fn-name "client-id", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLIENT" "ID"], :fn-docstring "Returns the client ID for the current connection.\n\nCLIENT ID \n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"CLIENT INFO" {:fn-name "client-info", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLIENT" "INFO"], :fn-docstring "Returns information about the current client connection..\n\nCLIENT INFO \n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"CLIENT KILL" {:fn-name "client-kill", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["CLIENT" "KILL"], :fn-docstring "Kill the connection of a client.\n\nCLIENT KILL [ip:port] [client-id] [normal_master_slave_pubsub] [username] [ip:port] [ip:port] [yes/no]\n\nAvailable since: 2.4.0.\n\nTime complexity: O(N) where N is the number of client connections"}
"CLIENT LIST" {:fn-name "client-list", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["CLIENT" "LIST"], :fn-docstring "Get the list of client connections.\n\nCLIENT LIST [normal_master_replica_pubsub] [id]\n\nAvailable since: 2.4.0.\n\nTime complexity: O(N) where N is the number of client connections"}
"CLIENT NO-EVICT" {:fn-name "client-no-evict", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [enabled], :req-args-fixed ["CLIENT" "NO-EVICT" enabled], :fn-docstring "Set client eviction mode for the current connection.\n\nCLIENT NO-EVICT enabled\n\nAvailable since: 7.0.0.\n\nTime complexity: O(1)"}
"CLIENT PAUSE" {:fn-name "client-pause", :cluster-key-idx 2, :fn-params-more [timeout & args], :fn-params-fixed [timeout], :req-args-fixed ["CLIENT" "PAUSE" timeout], :fn-docstring "Stop processing commands from clients for some time.\n\nCLIENT PAUSE timeout [mode]\n\nAvailable since: 2.9.50.\n\nTime complexity: O(1)"}
"CLIENT REPLY" {:fn-name "client-reply", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [on_off_skip], :req-args-fixed ["CLIENT" "REPLY" on_off_skip], :fn-docstring "Instruct the server whether to reply to commands.\n\nCLIENT REPLY on_off_skip\n\nAvailable since: 3.2.0.\n\nTime complexity: O(1)"}
"CLIENT SETNAME" {:fn-name "client-setname", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [connection-name], :req-args-fixed ["CLIENT" "SETNAME" connection-name], :fn-docstring "Set the current connection name.\n\nCLIENT SETNAME connection-name\n\nAvailable since: 2.6.9.\n\nTime complexity: O(1)"}
"CLIENT TRACKING" {:fn-name "client-tracking", :cluster-key-idx 2, :fn-params-more [status & args], :fn-params-fixed [status], :req-args-fixed ["CLIENT" "TRACKING" status], :fn-docstring "Enable or disable server assisted client side caching support.\n\nCLIENT TRACKING status [client-id] [prefix [prefix ...]] [bcast] [optin] [optout] [noloop]\n\nAvailable since: 6.0.0.\n\nTime complexity: O(1). Some options may introduce additional complexity."}
"CLIENT TRACKINGINFO" {:fn-name "client-trackinginfo", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLIENT" "TRACKINGINFO"], :fn-docstring "Return information about server assisted client side caching for the current connection.\n\nCLIENT TRACKINGINFO \n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"CLIENT UNBLOCK" {:fn-name "client-unblock", :cluster-key-idx 2, :fn-params-more [client-id & args], :fn-params-fixed [client-id], :req-args-fixed ["CLIENT" "UNBLOCK" client-id], :fn-docstring "Unblock a client blocked in a blocking command from a different connection.\n\nCLIENT UNBLOCK client-id [timeout_error]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(log N) where N is the number of client connections"}
"CLIENT UNPAUSE" {:fn-name "client-unpause", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLIENT" "UNPAUSE"], :fn-docstring "Resume processing of clients that were paused.\n\nCLIENT UNPAUSE \n\nAvailable since: 6.2.0.\n\nTime complexity: O(N) Where N is the number of paused clients"}
"CLUSTER" {:fn-name "cluster", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER"], :fn-docstring "A container for cluster commands.\n\nCLUSTER \n\nAvailable since: 3.0.0.\n\nTime complexity: Depends on subcommand."}
"CLUSTER ADDSLOTS" {:fn-name "cluster-addslots", :cluster-key-idx 2, :fn-params-more [slot & args], :fn-params-fixed [slot], :req-args-fixed ["CLUSTER" "ADDSLOTS" slot], :fn-docstring "Assign new hash slots to receiving node.\n\nCLUSTER ADDSLOTS slot [slot ...]\n\nAvailable since: 3.0.0.\n\nTime complexity: O(N) where N is the total number of hash slot arguments"}
"CLUSTER ADDSLOTSRANGE" {:fn-name "cluster-addslotsrange", :cluster-key-idx 2, :fn-params-more [start-slot_end-slot & args], :fn-params-fixed [start-slot_end-slot], :req-args-fixed ["CLUSTER" "ADDSLOTSRANGE" start-slot_end-slot], :fn-docstring "Assign new hash slots to receiving node.\n\nCLUSTER ADDSLOTSRANGE start-slot_end-slot [start-slot_end-slot ...]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the total number of the slots between the start slot and end slot arguments."}
"CLUSTER BUMPEPOCH" {:fn-name "cluster-bumpepoch", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "BUMPEPOCH"], :fn-docstring "Advance the cluster config epoch.\n\nCLUSTER BUMPEPOCH \n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER COUNT-FAILURE-REPORTS" {:fn-name "cluster-count-failure-reports", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [node-id], :req-args-fixed ["CLUSTER" "COUNT-FAILURE-REPORTS" node-id], :fn-docstring "Return the number of failure reports active for a given node.\n\nCLUSTER COUNT-FAILURE-REPORTS node-id\n\nAvailable since: 3.0.0.\n\nTime complexity: O(N) where N is the number of failure reports"}
"CLUSTER COUNTKEYSINSLOT" {:fn-name "cluster-countkeysinslot", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [slot], :req-args-fixed ["CLUSTER" "COUNTKEYSINSLOT" slot], :fn-docstring "Return the number of local keys in the specified hash slot.\n\nCLUSTER COUNTKEYSINSLOT slot\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER DELSLOTS" {:fn-name "cluster-delslots", :cluster-key-idx 2, :fn-params-more [slot & args], :fn-params-fixed [slot], :req-args-fixed ["CLUSTER" "DELSLOTS" slot], :fn-docstring "Set hash slots as unbound in receiving node.\n\nCLUSTER DELSLOTS slot [slot ...]\n\nAvailable since: 3.0.0.\n\nTime complexity: O(N) where N is the total number of hash slot arguments"}
"CLUSTER DELSLOTSRANGE" {:fn-name "cluster-delslotsrange", :cluster-key-idx 2, :fn-params-more [start-slot_end-slot & args], :fn-params-fixed [start-slot_end-slot], :req-args-fixed ["CLUSTER" "DELSLOTSRANGE" start-slot_end-slot], :fn-docstring "Set hash slots as unbound in receiving node.\n\nCLUSTER DELSLOTSRANGE start-slot_end-slot [start-slot_end-slot ...]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the total number of the slots between the start slot and end slot arguments."}
"CLUSTER FAILOVER" {:fn-name "cluster-failover", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["CLUSTER" "FAILOVER"], :fn-docstring "Forces a replica to perform a manual failover of its master..\n\nCLUSTER FAILOVER [options]\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER FLUSHSLOTS" {:fn-name "cluster-flushslots", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "FLUSHSLOTS"], :fn-docstring "Delete a node's own slots information.\n\nCLUSTER FLUSHSLOTS \n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER FORGET" {:fn-name "cluster-forget", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [node-id], :req-args-fixed ["CLUSTER" "FORGET" node-id], :fn-docstring "Remove a node from the nodes table.\n\nCLUSTER FORGET node-id\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER GETKEYSINSLOT" {:fn-name "cluster-getkeysinslot", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [slot count], :req-args-fixed ["CLUSTER" "GETKEYSINSLOT" slot count], :fn-docstring "Return local key names in the specified hash slot.\n\nCLUSTER GETKEYSINSLOT slot count\n\nAvailable since: 3.0.0.\n\nTime complexity: O(log(N)) where N is the number of requested keys"}
"CLUSTER HELP" {:fn-name "cluster-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nCLUSTER HELP \n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"CLUSTER INFO" {:fn-name "cluster-info", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "INFO"], :fn-docstring "Provides info about Redis Cluster node state.\n\nCLUSTER INFO \n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER KEYSLOT" {:fn-name "cluster-keyslot", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["CLUSTER" "KEYSLOT" key], :fn-docstring "Returns the hash slot of the specified key.\n\nCLUSTER KEYSLOT key\n\nAvailable since: 3.0.0.\n\nTime complexity: O(N) where N is the number of bytes in the key"}
"CLUSTER LINKS" {:fn-name "cluster-links", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "LINKS"], :fn-docstring "Returns a list of all TCP links to and from peer nodes in cluster.\n\nCLUSTER LINKS \n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the total number of Cluster nodes"}
"CLUSTER MEET" {:fn-name "cluster-meet", :cluster-key-idx 2, :fn-params-more [ip port & args], :fn-params-fixed [ip port], :req-args-fixed ["CLUSTER" "MEET" ip port], :fn-docstring "Force a node cluster to handshake with another node.\n\nCLUSTER MEET ip port [cluster_bus_port]\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER MYID" {:fn-name "cluster-myid", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "MYID"], :fn-docstring "Return the node id.\n\nCLUSTER MYID \n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER NODES" {:fn-name "cluster-nodes", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "NODES"], :fn-docstring "Get Cluster config for the node.\n\nCLUSTER NODES \n\nAvailable since: 3.0.0.\n\nTime complexity: O(N) where N is the total number of Cluster nodes"}
"CLUSTER REPLICAS" {:fn-name "cluster-replicas", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [node-id], :req-args-fixed ["CLUSTER" "REPLICAS" node-id], :fn-docstring "List replica nodes of the specified master node.\n\nCLUSTER REPLICAS node-id\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"CLUSTER REPLICATE" {:fn-name "cluster-replicate", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [node-id], :req-args-fixed ["CLUSTER" "REPLICATE" node-id], :fn-docstring "Reconfigure a node as a replica of the specified master node.\n\nCLUSTER REPLICATE node-id\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER RESET" {:fn-name "cluster-reset", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["CLUSTER" "RESET"], :fn-docstring "Reset a Redis Cluster node.\n\nCLUSTER RESET [hard_soft]\n\nAvailable since: 3.0.0.\n\nTime complexity: O(N) where N is the number of known nodes. The command may execute a FLUSHALL as a side effect."}
"CLUSTER SAVECONFIG" {:fn-name "cluster-saveconfig", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "SAVECONFIG"], :fn-docstring "Forces the node to save cluster state on disk.\n\nCLUSTER SAVECONFIG \n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER SET-CONFIG-EPOCH" {:fn-name "cluster-set-config-epoch", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [config-epoch], :req-args-fixed ["CLUSTER" "SET-CONFIG-EPOCH" config-epoch], :fn-docstring "Set the configuration epoch in a new node.\n\nCLUSTER SET-CONFIG-EPOCH config-epoch\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER SETSLOT" {:fn-name "cluster-setslot", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [slot subcommand], :req-args-fixed ["CLUSTER" "SETSLOT" slot subcommand], :fn-docstring "Bind a hash slot to a specific node.\n\nCLUSTER SETSLOT slot subcommand\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER SHARDS" {:fn-name "cluster-shards", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "SHARDS"], :fn-docstring "Get array of cluster slots to node mappings.\n\nCLUSTER SHARDS \n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the total number of cluster nodes"}
"CLUSTER SLAVES" {:fn-name "cluster-slaves", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [node-id], :req-args-fixed ["CLUSTER" "SLAVES" node-id], :fn-docstring "List replica nodes of the specified master node.\n\nCLUSTER SLAVES node-id\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"CLUSTER SLOTS" {:fn-name "cluster-slots", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CLUSTER" "SLOTS"], :fn-docstring "Get array of Cluster slot to node mappings.\n\nCLUSTER SLOTS \n\nAvailable since: 3.0.0.\n\nTime complexity: O(N) where N is the total number of Cluster nodes"}
"COMMAND" {:fn-name "command", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["COMMAND"], :fn-docstring "Get array of Redis command details.\n\nCOMMAND \n\nAvailable since: 2.8.13.\n\nTime complexity: O(N) where N is the total number of Redis commands"}
"COMMAND COUNT" {:fn-name "command-count", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["COMMAND" "COUNT"], :fn-docstring "Get total number of Redis commands.\n\nCOMMAND COUNT \n\nAvailable since: 2.8.13.\n\nTime complexity: O(1)"}
"COMMAND DOCS" {:fn-name "command-docs", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["COMMAND" "DOCS"], :fn-docstring "Get array of specific Redis command documentation.\n\nCOMMAND DOCS [command-name [command-name ...]]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of commands to look up"}
"COMMAND GETKEYS" {:fn-name "command-getkeys", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["COMMAND" "GETKEYS"], :fn-docstring "Extract keys given a full Redis command.\n\nCOMMAND GETKEYS \n\nAvailable since: 2.8.13.\n\nTime complexity: O(N) where N is the number of arguments to the command"}
"COMMAND GETKEYSANDFLAGS" {:fn-name "command-getkeysandflags", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["COMMAND" "GETKEYSANDFLAGS"], :fn-docstring "Extract keys and access flags given a full Redis command.\n\nCOMMAND GETKEYSANDFLAGS \n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of arguments to the command"}
"COMMAND HELP" {:fn-name "command-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["COMMAND" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nCOMMAND HELP \n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"COMMAND INFO" {:fn-name "command-info", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["COMMAND" "INFO"], :fn-docstring "Get array of specific Redis command details, or all when no argument is given..\n\nCOMMAND INFO [command-name [command-name ...]]\n\nAvailable since: 2.8.13.\n\nTime complexity: O(N) where N is the number of commands to look up"}
"COMMAND LIST" {:fn-name "command-list", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["COMMAND" "LIST"], :fn-docstring "Get an array of Redis command names.\n\nCOMMAND LIST [filterby]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the total number of Redis commands"}
"CONFIG" {:fn-name "config", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CONFIG"], :fn-docstring "A container for server configuration commands.\n\nCONFIG \n\nAvailable since: 2.0.0.\n\nTime complexity: Depends on subcommand."}
"CONFIG GET" {:fn-name "config-get", :cluster-key-idx 2, :fn-params-more [parameter & args], :fn-params-fixed [parameter], :req-args-fixed ["CONFIG" "GET" parameter], :fn-docstring "Get the values of configuration parameters.\n\nCONFIG GET parameter [parameter ...]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) when N is the number of configuration parameters provided"}
"CONFIG HELP" {:fn-name "config-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CONFIG" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nCONFIG HELP \n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"CONFIG RESETSTAT" {:fn-name "config-resetstat", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CONFIG" "RESETSTAT"], :fn-docstring "Reset the stats returned by INFO.\n\nCONFIG RESETSTAT \n\nAvailable since: 2.0.0.\n\nTime complexity: O(1)"}
"CONFIG REWRITE" {:fn-name "config-rewrite", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["CONFIG" "REWRITE"], :fn-docstring "Rewrite the configuration file with the in memory configuration.\n\nCONFIG REWRITE \n\nAvailable since: 2.8.0.\n\nTime complexity: O(1)"}
"CONFIG SET" {:fn-name "config-set", :cluster-key-idx 2, :fn-params-more [parameter_value & args], :fn-params-fixed [parameter_value], :req-args-fixed ["CONFIG" "SET" parameter_value], :fn-docstring "Set configuration parameters to the given values.\n\nCONFIG SET parameter_value [parameter_value ...]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) when N is the number of configuration parameters provided"}
"COPY" {:fn-name "copy", :cluster-key-idx 1, :fn-params-more [source destination & args], :fn-params-fixed [source destination], :req-args-fixed ["COPY" source destination], :fn-docstring "Copy a key.\n\nCOPY source destination [destination-db] [replace]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(N) worst case for collections, where N is the number of nested items. O(1) for string values."}
"DBSIZE" {:fn-name "dbsize", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["DBSIZE"], :fn-docstring "Return the number of keys in the selected database.\n\nDBSIZE \n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"DEBUG" {:fn-name "debug", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["DEBUG"], :fn-docstring "A container for debugging commands.\n\nDEBUG \n\nAvailable since: 1.0.0.\n\nTime complexity: Depends on subcommand."}
"DECR" {:fn-name "decr", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["DECR" key], :fn-docstring "Decrement the integer value of a key by one.\n\nDECR key\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"DECRBY" {:fn-name "decrby", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key decrement], :req-args-fixed ["DECRBY" key decrement], :fn-docstring "Decrement the integer value of a key by the given number.\n\nDECRBY key decrement\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"DEL" {:fn-name "del", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["DEL" key], :fn-docstring "Delete a key.\n\nDEL key [key ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1)."}
"DISCARD" {:fn-name "discard", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["DISCARD"], :fn-docstring "Discard all commands issued after MULTI.\n\nDISCARD \n\nAvailable since: 2.0.0.\n\nTime complexity: O(N), when N is the number of queued commands"}
"DUMP" {:fn-name "dump", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["DUMP" key], :fn-docstring "Return a serialized version of the value stored at the specified key..\n\nDUMP key\n\nAvailable since: 2.6.0.\n\nTime complexity: O(1) to access the key and additional O(N*M) to serialize it, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1)."}
"ECHO" {:fn-name "echo", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [message], :req-args-fixed ["ECHO" message], :fn-docstring "Echo the given string.\n\nECHO message\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"EVAL" {:fn-name "eval", :cluster-key-idx 1, :fn-params-more [script numkeys & args], :fn-params-fixed [script numkeys], :req-args-fixed ["EVAL" script numkeys], :fn-docstring "Execute a Lua script server side.\n\nEVAL script numkeys [key [key ...]] [arg [arg ...]]\n\nAvailable since: 2.6.0.\n\nTime complexity: Depends on the script that is executed."}
"EVALSHA" {:fn-name "evalsha", :cluster-key-idx 1, :fn-params-more [sha1 numkeys & args], :fn-params-fixed [sha1 numkeys], :req-args-fixed ["EVALSHA" sha1 numkeys], :fn-docstring "Execute a Lua script server side.\n\nEVALSHA sha1 numkeys [key [key ...]] [arg [arg ...]]\n\nAvailable since: 2.6.0.\n\nTime complexity: Depends on the script that is executed."}
"EVALSHA_RO" {:fn-name "evalsha_ro", :cluster-key-idx 1, :fn-params-more [sha1 numkeys key & args], :fn-params-fixed [sha1 numkeys key], :req-args-fixed ["EVALSHA_RO" sha1 numkeys key], :fn-docstring "Execute a read-only Lua script server side.\n\nEVALSHA_RO sha1 numkeys key [key ...] arg [arg ...]\n\nAvailable since: 7.0.0.\n\nTime complexity: Depends on the script that is executed."}
"EVAL_RO" {:fn-name "eval_ro", :cluster-key-idx 1, :fn-params-more [script numkeys key & args], :fn-params-fixed [script numkeys key], :req-args-fixed ["EVAL_RO" script numkeys key], :fn-docstring "Execute a read-only Lua script server side.\n\nEVAL_RO script numkeys key [key ...] arg [arg ...]\n\nAvailable since: 7.0.0.\n\nTime complexity: Depends on the script that is executed."}
"EXEC" {:fn-name "exec", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["EXEC"], :fn-docstring "Execute all commands issued after MULTI.\n\nEXEC \n\nAvailable since: 1.2.0.\n\nTime complexity: Depends on commands in the transaction"}
"EXISTS" {:fn-name "exists", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["EXISTS" key], :fn-docstring "Determine if a key exists.\n\nEXISTS key [key ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of keys to check."}
"EXPIRE" {:fn-name "expire", :cluster-key-idx 1, :fn-params-more [key seconds & args], :fn-params-fixed [key seconds], :req-args-fixed ["EXPIRE" key seconds], :fn-docstring "Set a key's time to live in seconds.\n\nEXPIRE key seconds [condition]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"EXPIREAT" {:fn-name "expireat", :cluster-key-idx 1, :fn-params-more [key unix-time-seconds & args], :fn-params-fixed [key unix-time-seconds], :req-args-fixed ["EXPIREAT" key unix-time-seconds], :fn-docstring "Set the expiration for a key as a UNIX timestamp.\n\nEXPIREAT key unix-time-seconds [condition]\n\nAvailable since: 1.2.0.\n\nTime complexity: O(1)"}
"EXPIRETIME" {:fn-name "expiretime", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["EXPIRETIME" key], :fn-docstring "Get the expiration Unix timestamp for a key.\n\nEXPIRETIME key\n\nAvailable since: 7.0.0.\n\nTime complexity: O(1)"}
"FAILOVER" {:fn-name "failover", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["FAILOVER"], :fn-docstring "Start a coordinated failover between this server and one of its replicas..\n\nFAILOVER [target] [abort] [milliseconds]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"FCALL" {:fn-name "fcall", :cluster-key-idx 1, :fn-params-more [function numkeys key & args], :fn-params-fixed [function numkeys key], :req-args-fixed ["FCALL" function numkeys key], :fn-docstring "Invoke a function.\n\nFCALL function numkeys key [key ...] arg [arg ...]\n\nAvailable since: 7.0.0.\n\nTime complexity: Depends on the function that is executed."}
"FCALL_RO" {:fn-name "fcall_ro", :cluster-key-idx 1, :fn-params-more [function numkeys key & args], :fn-params-fixed [function numkeys key], :req-args-fixed ["FCALL_RO" function numkeys key], :fn-docstring "Invoke a read-only function.\n\nFCALL_RO function numkeys key [key ...] arg [arg ...]\n\nAvailable since: 7.0.0.\n\nTime complexity: Depends on the function that is executed."}
"FLUSHALL" {:fn-name "flushall", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["FLUSHALL"], :fn-docstring "Remove all keys from all databases.\n\nFLUSHALL [async]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the total number of keys in all databases"}
"FLUSHDB" {:fn-name "flushdb", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["FLUSHDB"], :fn-docstring "Remove all keys from the current database.\n\nFLUSHDB [async]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of keys in the selected database"}
"FUNCTION" {:fn-name "function", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["FUNCTION"], :fn-docstring "A container for function commands.\n\nFUNCTION \n\nAvailable since: 7.0.0.\n\nTime complexity: Depends on subcommand."}
"FUNCTION DELETE" {:fn-name "function-delete", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [library-name], :req-args-fixed ["FUNCTION" "DELETE" library-name], :fn-docstring "Delete a function by name.\n\nFUNCTION DELETE library-name\n\nAvailable since: 7.0.0.\n\nTime complexity: O(1)"}
"FUNCTION DUMP" {:fn-name "function-dump", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["FUNCTION" "DUMP"], :fn-docstring "Dump all functions into a serialized binary payload.\n\nFUNCTION DUMP \n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of functions"}
"FUNCTION FLUSH" {:fn-name "function-flush", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["FUNCTION" "FLUSH"], :fn-docstring "Deleting all functions.\n\nFUNCTION FLUSH [async]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of functions deleted"}
"FUNCTION HELP" {:fn-name "function-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["FUNCTION" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nFUNCTION HELP \n\nAvailable since: 7.0.0.\n\nTime complexity: O(1)"}
"FUNCTION KILL" {:fn-name "function-kill", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["FUNCTION" "KILL"], :fn-docstring "Kill the function currently in execution..\n\nFUNCTION KILL \n\nAvailable since: 7.0.0.\n\nTime complexity: O(1)"}
"FUNCTION LIST" {:fn-name "function-list", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["FUNCTION" "LIST"], :fn-docstring "List information about all the functions.\n\nFUNCTION LIST [library-name-pattern] [withcode]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of functions"}
"FUNCTION LOAD" {:fn-name "function-load", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["FUNCTION" "LOAD"], :fn-docstring "Create a function with the given arguments (name, code, description).\n\nFUNCTION LOAD [replace] function-code\n\nAvailable since: 7.0.0.\n\nTime complexity: O(1) (considering compilation time is redundant)"}
"FUNCTION RESTORE" {:fn-name "function-restore", :cluster-key-idx 2, :fn-params-more [serialized-value & args], :fn-params-fixed [serialized-value], :req-args-fixed ["FUNCTION" "RESTORE" serialized-value], :fn-docstring "Restore all the functions on the given payload.\n\nFUNCTION RESTORE serialized-value [policy]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of functions on the payload"}
"FUNCTION STATS" {:fn-name "function-stats", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["FUNCTION" "STATS"], :fn-docstring "Return information about the function currently running (name, description, duration).\n\nFUNCTION STATS \n\nAvailable since: 7.0.0.\n\nTime complexity: O(1)"}
"GEOADD" {:fn-name "geoadd", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["GEOADD" key], :fn-docstring "Add one or more geospatial items in the geospatial index represented using a sorted set.\n\nGEOADD key [condition] [change] longitude_latitude_member [longitude_latitude_member ...]\n\nAvailable since: 3.2.0.\n\nTime complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set."}
"GEODIST" {:fn-name "geodist", :cluster-key-idx 1, :fn-params-more [key member1 member2 & args], :fn-params-fixed [key member1 member2], :req-args-fixed ["GEODIST" key member1 member2], :fn-docstring "Returns the distance between two members of a geospatial index.\n\nGEODIST key member1 member2 [unit]\n\nAvailable since: 3.2.0.\n\nTime complexity: O(log(N))"}
"GEOHASH" {:fn-name "geohash", :cluster-key-idx 1, :fn-params-more [key member & args], :fn-params-fixed [key member], :req-args-fixed ["GEOHASH" key member], :fn-docstring "Returns members of a geospatial index as standard geohash strings.\n\nGEOHASH key member [member ...]\n\nAvailable since: 3.2.0.\n\nTime complexity: O(log(N)) for each member requested, where N is the number of elements in the sorted set."}
"GEOPOS" {:fn-name "geopos", :cluster-key-idx 1, :fn-params-more [key member & args], :fn-params-fixed [key member], :req-args-fixed ["GEOPOS" key member], :fn-docstring "Returns longitude and latitude of members of a geospatial index.\n\nGEOPOS key member [member ...]\n\nAvailable since: 3.2.0.\n\nTime complexity: O(N) where N is the number of members requested."}
"GEORADIUS" {:fn-name "georadius", :cluster-key-idx 1, :fn-params-more [key longitude latitude radius unit & args], :fn-params-fixed [key longitude latitude radius unit], :req-args-fixed ["GEORADIUS" key longitude latitude radius unit], :fn-docstring "Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point.\n\nGEORADIUS key longitude latitude radius unit [withcoord] [withdist] [withhash] [count] [order] [key] [key]\n\nAvailable since: 3.2.0.\n\nTime complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index."}
"GEORADIUSBYMEMBER" {:fn-name "georadiusbymember", :cluster-key-idx 1, :fn-params-more [key member radius unit & args], :fn-params-fixed [key member radius unit], :req-args-fixed ["GEORADIUSBYMEMBER" key member radius unit], :fn-docstring "Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member.\n\nGEORADIUSBYMEMBER key member radius unit [withcoord] [withdist] [withhash] [count] [order] [key] [key]\n\nAvailable since: 3.2.0.\n\nTime complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index."}
"GEORADIUSBYMEMBER_RO" {:fn-name "georadiusbymember_ro", :cluster-key-idx 1, :fn-params-more [key member radius unit & args], :fn-params-fixed [key member radius unit], :req-args-fixed ["GEORADIUSBYMEMBER_RO" key member radius unit], :fn-docstring "A read-only variant for GEORADIUSBYMEMBER.\n\nGEORADIUSBYMEMBER_RO key member radius unit [withcoord] [withdist] [withhash] [count] [order]\n\nAvailable since: 3.2.10.\n\nTime complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index."}
"GEORADIUS_RO" {:fn-name "georadius_ro", :cluster-key-idx 1, :fn-params-more [key longitude latitude radius unit & args], :fn-params-fixed [key longitude latitude radius unit], :req-args-fixed ["GEORADIUS_RO" key longitude latitude radius unit], :fn-docstring "A read-only variant for GEORADIUS.\n\nGEORADIUS_RO key longitude latitude radius unit [withcoord] [withdist] [withhash] [count] [order]\n\nAvailable since: 3.2.10.\n\nTime complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index."}
"GEOSEARCH" {:fn-name "geosearch", :cluster-key-idx 1, :fn-params-more [key from by & args], :fn-params-fixed [key from by], :req-args-fixed ["GEOSEARCH" key from by], :fn-docstring "Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle..\n\nGEOSEARCH key from by [order] [count] [withcoord] [withdist] [withhash]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape"}
"GEOSEARCHSTORE" {:fn-name "geosearchstore", :cluster-key-idx 1, :fn-params-more [destination source from by & args], :fn-params-fixed [destination source from by], :req-args-fixed ["GEOSEARCHSTORE" destination source from by], :fn-docstring "Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key..\n\nGEOSEARCHSTORE destination source from by [order] [count] [storedist]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape"}
"GET" {:fn-name "get", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["GET" key], :fn-docstring "Get the value of a key.\n\nGET key\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"GETBIT" {:fn-name "getbit", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key offset], :req-args-fixed ["GETBIT" key offset], :fn-docstring "Returns the bit value at offset in the string value stored at key.\n\nGETBIT key offset\n\nAvailable since: 2.2.0.\n\nTime complexity: O(1)"}
"GETDEL" {:fn-name "getdel", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["GETDEL" key], :fn-docstring "Get the value of a key and delete the key.\n\nGETDEL key\n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"GETEX" {:fn-name "getex", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["GETEX" key], :fn-docstring "Get the value of a key and optionally set its expiration.\n\nGETEX key [expiration]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"GETRANGE" {:fn-name "getrange", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key start end], :req-args-fixed ["GETRANGE" key start end], :fn-docstring "Get a substring of the string stored at a key.\n\nGETRANGE key start end\n\nAvailable since: 2.4.0.\n\nTime complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings."}
"GETSET" {:fn-name "getset", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key value], :req-args-fixed ["GETSET" key value], :fn-docstring "Set the string value of a key and return its old value.\n\nGETSET key value\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"HDEL" {:fn-name "hdel", :cluster-key-idx 1, :fn-params-more [key field & args], :fn-params-fixed [key field], :req-args-fixed ["HDEL" key field], :fn-docstring "Delete one or more hash fields.\n\nHDEL key field [field ...]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the number of fields to be removed."}
"HELLO" {:fn-name "hello", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["HELLO"], :fn-docstring "Handshake with Redis.\n\nHELLO [arguments]\n\nAvailable since: 6.0.0.\n\nTime complexity: O(1)"}
"HEXISTS" {:fn-name "hexists", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key field], :req-args-fixed ["HEXISTS" key field], :fn-docstring "Determine if a hash field exists.\n\nHEXISTS key field\n\nAvailable since: 2.0.0.\n\nTime complexity: O(1)"}
"HGET" {:fn-name "hget", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key field], :req-args-fixed ["HGET" key field], :fn-docstring "Get the value of a hash field.\n\nHGET key field\n\nAvailable since: 2.0.0.\n\nTime complexity: O(1)"}
"HGETALL" {:fn-name "hgetall", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["HGETALL" key], :fn-docstring "Get all the fields and values in a hash.\n\nHGETALL key\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the size of the hash."}
"HINCRBY" {:fn-name "hincrby", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key field increment], :req-args-fixed ["HINCRBY" key field increment], :fn-docstring "Increment the integer value of a hash field by the given number.\n\nHINCRBY key field increment\n\nAvailable since: 2.0.0.\n\nTime complexity: O(1)"}
"HINCRBYFLOAT" {:fn-name "hincrbyfloat", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key field increment], :req-args-fixed ["HINCRBYFLOAT" key field increment], :fn-docstring "Increment the float value of a hash field by the given amount.\n\nHINCRBYFLOAT key field increment\n\nAvailable since: 2.6.0.\n\nTime complexity: O(1)"}
"HKEYS" {:fn-name "hkeys", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["HKEYS" key], :fn-docstring "Get all the fields in a hash.\n\nHKEYS key\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the size of the hash."}
"HLEN" {:fn-name "hlen", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["HLEN" key], :fn-docstring "Get the number of fields in a hash.\n\nHLEN key\n\nAvailable since: 2.0.0.\n\nTime complexity: O(1)"}
"HMGET" {:fn-name "hmget", :cluster-key-idx 1, :fn-params-more [key field & args], :fn-params-fixed [key field], :req-args-fixed ["HMGET" key field], :fn-docstring "Get the values of all the given hash fields.\n\nHMGET key field [field ...]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the number of fields being requested."}
"HMSET" {:fn-name "hmset", :cluster-key-idx 1, :fn-params-more [key field_value & args], :fn-params-fixed [key field_value], :req-args-fixed ["HMSET" key field_value], :fn-docstring "Set multiple hash fields to multiple values.\n\nHMSET key field_value [field_value ...]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the number of fields being set."}
"HRANDFIELD" {:fn-name "hrandfield", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["HRANDFIELD" key], :fn-docstring "Get one or multiple random fields from a hash.\n\nHRANDFIELD key [options]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(N) where N is the number of fields returned"}
"HSCAN" {:fn-name "hscan", :cluster-key-idx 1, :fn-params-more [key cursor & args], :fn-params-fixed [key cursor], :req-args-fixed ["HSCAN" key cursor], :fn-docstring "Incrementally iterate hash fields and associated values.\n\nHSCAN key cursor [pattern] [count]\n\nAvailable since: 2.8.0.\n\nTime complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.."}
"HSET" {:fn-name "hset", :cluster-key-idx 1, :fn-params-more [key field_value & args], :fn-params-fixed [key field_value], :req-args-fixed ["HSET" key field_value], :fn-docstring "Set the string value of a hash field.\n\nHSET key field_value [field_value ...]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(1) for each field/value pair added, so O(N) to add N field/value pairs when the command is called with multiple field/value pairs."}
"HSETNX" {:fn-name "hsetnx", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key field value], :req-args-fixed ["HSETNX" key field value], :fn-docstring "Set the value of a hash field, only if the field does not exist.\n\nHSETNX key field value\n\nAvailable since: 2.0.0.\n\nTime complexity: O(1)"}
"HSTRLEN" {:fn-name "hstrlen", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key field], :req-args-fixed ["HSTRLEN" key field], :fn-docstring "Get the length of the value of a hash field.\n\nHSTRLEN key field\n\nAvailable since: 3.2.0.\n\nTime complexity: O(1)"}
"HVALS" {:fn-name "hvals", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["HVALS" key], :fn-docstring "Get all the values in a hash.\n\nHVALS key\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the size of the hash."}
"INCR" {:fn-name "incr", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["INCR" key], :fn-docstring "Increment the integer value of a key by one.\n\nINCR key\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"INCRBY" {:fn-name "incrby", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key increment], :req-args-fixed ["INCRBY" key increment], :fn-docstring "Increment the integer value of a key by the given amount.\n\nINCRBY key increment\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"INCRBYFLOAT" {:fn-name "incrbyfloat", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key increment], :req-args-fixed ["INCRBYFLOAT" key increment], :fn-docstring "Increment the float value of a key by the given amount.\n\nINCRBYFLOAT key increment\n\nAvailable since: 2.6.0.\n\nTime complexity: O(1)"}
"INFO" {:fn-name "info", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["INFO"], :fn-docstring "Get information and statistics about the server.\n\nINFO [section [section ...]]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"KEYS" {:fn-name "keys", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [pattern], :req-args-fixed ["KEYS" pattern], :fn-docstring "Find all keys matching the given pattern.\n\nKEYS pattern\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length."}
"LASTSAVE" {:fn-name "lastsave", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["LASTSAVE"], :fn-docstring "Get the UNIX time stamp of the last successful save to disk.\n\nLASTSAVE \n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"LATENCY" {:fn-name "latency", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["LATENCY"], :fn-docstring "A container for latency diagnostics commands.\n\nLATENCY \n\nAvailable since: 2.8.13.\n\nTime complexity: Depends on subcommand."}
"LATENCY DOCTOR" {:fn-name "latency-doctor", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["LATENCY" "DOCTOR"], :fn-docstring "Return a human readable latency analysis report..\n\nLATENCY DOCTOR \n\nAvailable since: 2.8.13.\n\nTime complexity: O(1)"}
"LATENCY GRAPH" {:fn-name "latency-graph", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [event], :req-args-fixed ["LATENCY" "GRAPH" event], :fn-docstring "Return a latency graph for the event..\n\nLATENCY GRAPH event\n\nAvailable since: 2.8.13.\n\nTime complexity: O(1)"}
"LATENCY HELP" {:fn-name "latency-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["LATENCY" "HELP"], :fn-docstring "Show helpful text about the different subcommands..\n\nLATENCY HELP \n\nAvailable since: 2.8.13.\n\nTime complexity: O(1)"}
"LATENCY HISTOGRAM" {:fn-name "latency-histogram", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["LATENCY" "HISTOGRAM"], :fn-docstring "Return the cumulative distribution of latencies of a subset of commands or all..\n\nLATENCY HISTOGRAM [command [command ...]]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of commands with latency information being retrieved."}
"LATENCY HISTORY" {:fn-name "latency-history", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [event], :req-args-fixed ["LATENCY" "HISTORY" event], :fn-docstring "Return timestamp-latency samples for the event..\n\nLATENCY HISTORY event\n\nAvailable since: 2.8.13.\n\nTime complexity: O(1)"}
"LATENCY LATEST" {:fn-name "latency-latest", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["LATENCY" "LATEST"], :fn-docstring "Return the latest latency samples for all events..\n\nLATENCY LATEST \n\nAvailable since: 2.8.13.\n\nTime complexity: O(1)"}
"LATENCY RESET" {:fn-name "latency-reset", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["LATENCY" "RESET"], :fn-docstring "Reset latency data for one or more events..\n\nLATENCY RESET [event [event ...]]\n\nAvailable since: 2.8.13.\n\nTime complexity: O(1)"}
"LCS" {:fn-name "lcs", :cluster-key-idx 1, :fn-params-more [key1 key2 & args], :fn-params-fixed [key1 key2], :req-args-fixed ["LCS" key1 key2], :fn-docstring "Find longest common substring.\n\nLCS key1 key2 [len] [idx] [len] [withmatchlen]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N*M) where N and M are the lengths of s1 and s2, respectively"}
"LINDEX" {:fn-name "lindex", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key index], :req-args-fixed ["LINDEX" key index], :fn-docstring "Get an element from a list by its index.\n\nLINDEX key index\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of elements to traverse to get to the element at index. This makes asking for the first or the last element of the list O(1)."}
"LINSERT" {:fn-name "linsert", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key where pivot element], :req-args-fixed ["LINSERT" key where pivot element], :fn-docstring "Insert an element before or after another element in a list.\n\nLINSERT key where pivot element\n\nAvailable since: 2.2.0.\n\nTime complexity: O(N) where N is the number of elements to traverse before seeing the value pivot. This means that inserting somewhere on the left end on the list (head) can be considered O(1) and inserting somewhere on the right end (tail) is O(N)."}
"LLEN" {:fn-name "llen", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["LLEN" key], :fn-docstring "Get the length of a list.\n\nLLEN key\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"LMOVE" {:fn-name "lmove", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [source destination wherefrom whereto], :req-args-fixed ["LMOVE" source destination wherefrom whereto], :fn-docstring "Pop an element from a list, push it to another list and return it.\n\nLMOVE source destination wherefrom whereto\n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"LMPOP" {:fn-name "lmpop", :cluster-key-idx 1, :fn-params-more [numkeys key & args], :fn-params-fixed [numkeys key], :req-args-fixed ["LMPOP" numkeys key], :fn-docstring "Pop elements from a list.\n\nLMPOP numkeys key [key ...] where [count]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N+M) where N is the number of provided keys and M is the number of elements returned."}
"LOLWUT" {:fn-name "lolwut", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["LOLWUT"], :fn-docstring "Display some computer art and the Redis version.\n\nLOLWUT [version]\n\nAvailable since: 5.0.0.\n\n"}
"LPOP" {:fn-name "lpop", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["LPOP" key], :fn-docstring "Remove and get the first elements in a list.\n\nLPOP key [count]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of elements returned"}
"LPOS" {:fn-name "lpos", :cluster-key-idx 1, :fn-params-more [key element & args], :fn-params-fixed [key element], :req-args-fixed ["LPOS" key element], :fn-docstring "Return the index of matching elements on a list.\n\nLPOS key element [rank] [num-matches] [len]\n\nAvailable since: 6.0.6.\n\nTime complexity: O(N) where N is the number of elements in the list, for the average case. When searching for elements near the head or the tail of the list, or when the MAXLEN option is provided, the command may run in constant time."}
"LPUSH" {:fn-name "lpush", :cluster-key-idx 1, :fn-params-more [key element & args], :fn-params-fixed [key element], :req-args-fixed ["LPUSH" key element], :fn-docstring "Prepend one or multiple elements to a list.\n\nLPUSH key element [element ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments."}
"LPUSHX" {:fn-name "lpushx", :cluster-key-idx 1, :fn-params-more [key element & args], :fn-params-fixed [key element], :req-args-fixed ["LPUSHX" key element], :fn-docstring "Prepend an element to a list, only if the list exists.\n\nLPUSHX key element [element ...]\n\nAvailable since: 2.2.0.\n\nTime complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments."}
"LRANGE" {:fn-name "lrange", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key start stop], :req-args-fixed ["LRANGE" key start stop], :fn-docstring "Get a range of elements from a list.\n\nLRANGE key start stop\n\nAvailable since: 1.0.0.\n\nTime complexity: O(S+N) where S is the distance of start offset from HEAD for small lists, from nearest end (HEAD or TAIL) for large lists; and N is the number of elements in the specified range."}
"LREM" {:fn-name "lrem", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key count element], :req-args-fixed ["LREM" key count element], :fn-docstring "Remove elements from a list.\n\nLREM key count element\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N+M) where N is the length of the list and M is the number of elements removed."}
"LSET" {:fn-name "lset", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key index element], :req-args-fixed ["LSET" key index element], :fn-docstring "Set the value of an element in a list by its index.\n\nLSET key index element\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the length of the list. Setting either the first or the last element of the list is O(1)."}
"LTRIM" {:fn-name "ltrim", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key start stop], :req-args-fixed ["LTRIM" key start stop], :fn-docstring "Trim a list to the specified range.\n\nLTRIM key start stop\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of elements to be removed by the operation."}
"MEMORY" {:fn-name "memory", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MEMORY"], :fn-docstring "A container for memory diagnostics commands.\n\nMEMORY \n\nAvailable since: 4.0.0.\n\nTime complexity: Depends on subcommand."}
"MEMORY DOCTOR" {:fn-name "memory-doctor", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MEMORY" "DOCTOR"], :fn-docstring "Outputs memory problems report.\n\nMEMORY DOCTOR \n\nAvailable since: 4.0.0.\n\nTime complexity: O(1)"}
"MEMORY HELP" {:fn-name "memory-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MEMORY" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nMEMORY HELP \n\nAvailable since: 4.0.0.\n\nTime complexity: O(1)"}
"MEMORY MALLOC-STATS" {:fn-name "memory-malloc-stats", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MEMORY" "MALLOC-STATS"], :fn-docstring "Show allocator internal stats.\n\nMEMORY MALLOC-STATS \n\nAvailable since: 4.0.0.\n\nTime complexity: Depends on how much memory is allocated, could be slow"}
"MEMORY PURGE" {:fn-name "memory-purge", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MEMORY" "PURGE"], :fn-docstring "Ask the allocator to release memory.\n\nMEMORY PURGE \n\nAvailable since: 4.0.0.\n\nTime complexity: Depends on how much memory is allocated, could be slow"}
"MEMORY STATS" {:fn-name "memory-stats", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MEMORY" "STATS"], :fn-docstring "Show memory usage details.\n\nMEMORY STATS \n\nAvailable since: 4.0.0.\n\nTime complexity: O(1)"}
"MEMORY USAGE" {:fn-name "memory-usage", :cluster-key-idx 2, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["MEMORY" "USAGE" key], :fn-docstring "Estimate the memory usage of a key.\n\nMEMORY USAGE key [count]\n\nAvailable since: 4.0.0.\n\nTime complexity: O(N) where N is the number of samples."}
"MGET" {:fn-name "mget", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["MGET" key], :fn-docstring "Get the values of all the given keys.\n\nMGET key [key ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of keys to retrieve."}
"MIGRATE" {:fn-name "migrate", :cluster-key-idx 1, :fn-params-more [host port key_or_empty_string destination-db timeout & args], :fn-params-fixed [host port key_or_empty_string destination-db timeout], :req-args-fixed ["MIGRATE" host port key_or_empty_string destination-db timeout], :fn-docstring "Atomically transfer a key from a Redis instance to another one..\n\nMIGRATE host port key_or_empty_string destination-db timeout [copy] [replace] [authentication] [key [key ...]]\n\nAvailable since: 2.6.0.\n\nTime complexity: This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed."}
"MODULE" {:fn-name "module", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MODULE"], :fn-docstring "A container for module commands.\n\nMODULE \n\nAvailable since: 4.0.0.\n\nTime complexity: Depends on subcommand."}
"MODULE HELP" {:fn-name "module-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MODULE" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nMODULE HELP \n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"MODULE LIST" {:fn-name "module-list", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MODULE" "LIST"], :fn-docstring "List all modules loaded by the server.\n\nMODULE LIST \n\nAvailable since: 4.0.0.\n\nTime complexity: O(N) where N is the number of loaded modules."}
"MODULE LOAD" {:fn-name "module-load", :cluster-key-idx 2, :fn-params-more [path & args], :fn-params-fixed [path], :req-args-fixed ["MODULE" "LOAD" path], :fn-docstring "Load a module.\n\nMODULE LOAD path [arg [arg ...]]\n\nAvailable since: 4.0.0.\n\nTime complexity: O(1)"}
"MODULE LOADEX" {:fn-name "module-loadex", :cluster-key-idx 2, :fn-params-more [path & args], :fn-params-fixed [path], :req-args-fixed ["MODULE" "LOADEX" path], :fn-docstring "Load a module with extended parameters.\n\nMODULE LOADEX path [configs [configs ...]] [args [args ...]]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(1)"}
"MODULE UNLOAD" {:fn-name "module-unload", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [name], :req-args-fixed ["MODULE" "UNLOAD" name], :fn-docstring "Unload a module.\n\nMODULE UNLOAD name\n\nAvailable since: 4.0.0.\n\nTime complexity: O(1)"}
"MONITOR" {:fn-name "monitor", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MONITOR"], :fn-docstring "Listen for all requests received by the server in real time.\n\nMONITOR \n\nAvailable since: 1.0.0.\n\n"}
"MOVE" {:fn-name "move", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key db], :req-args-fixed ["MOVE" key db], :fn-docstring "Move a key to another database.\n\nMOVE key db\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"MSET" {:fn-name "mset", :cluster-key-idx 1, :fn-params-more [key_value & args], :fn-params-fixed [key_value], :req-args-fixed ["MSET" key_value], :fn-docstring "Set multiple keys to multiple values.\n\nMSET key_value [key_value ...]\n\nAvailable since: 1.0.1.\n\nTime complexity: O(N) where N is the number of keys to set."}
"MSETNX" {:fn-name "msetnx", :cluster-key-idx 1, :fn-params-more [key_value & args], :fn-params-fixed [key_value], :req-args-fixed ["MSETNX" key_value], :fn-docstring "Set multiple keys to multiple values, only if none of the keys exist.\n\nMSETNX key_value [key_value ...]\n\nAvailable since: 1.0.1.\n\nTime complexity: O(N) where N is the number of keys to set."}
"MULTI" {:fn-name "multi", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["MULTI"], :fn-docstring "Mark the start of a transaction block.\n\nMULTI \n\nAvailable since: 1.2.0.\n\nTime complexity: O(1)"}
"OBJECT" {:fn-name "object", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["OBJECT"], :fn-docstring "A container for object introspection commands.\n\nOBJECT \n\nAvailable since: 2.2.3.\n\nTime complexity: Depends on subcommand."}
"OBJECT ENCODING" {:fn-name "object-encoding", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["OBJECT" "ENCODING" key], :fn-docstring "Inspect the internal encoding of a Redis object.\n\nOBJECT ENCODING key\n\nAvailable since: 2.2.3.\n\nTime complexity: O(1)"}
"OBJECT FREQ" {:fn-name "object-freq", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["OBJECT" "FREQ" key], :fn-docstring "Get the logarithmic access frequency counter of a Redis object.\n\nOBJECT FREQ key\n\nAvailable since: 4.0.0.\n\nTime complexity: O(1)"}
"OBJECT HELP" {:fn-name "object-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["OBJECT" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nOBJECT HELP \n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"OBJECT IDLETIME" {:fn-name "object-idletime", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["OBJECT" "IDLETIME" key], :fn-docstring "Get the time since a Redis object was last accessed.\n\nOBJECT IDLETIME key\n\nAvailable since: 2.2.3.\n\nTime complexity: O(1)"}
"OBJECT REFCOUNT" {:fn-name "object-refcount", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["OBJECT" "REFCOUNT" key], :fn-docstring "Get the number of references to the value of the key.\n\nOBJECT REFCOUNT key\n\nAvailable since: 2.2.3.\n\nTime complexity: O(1)"}
"PERSIST" {:fn-name "persist", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["PERSIST" key], :fn-docstring "Remove the expiration from a key.\n\nPERSIST key\n\nAvailable since: 2.2.0.\n\nTime complexity: O(1)"}
"PEXPIRE" {:fn-name "pexpire", :cluster-key-idx 1, :fn-params-more [key milliseconds & args], :fn-params-fixed [key milliseconds], :req-args-fixed ["PEXPIRE" key milliseconds], :fn-docstring "Set a key's time to live in milliseconds.\n\nPEXPIRE key milliseconds [condition]\n\nAvailable since: 2.6.0.\n\nTime complexity: O(1)"}
"PEXPIREAT" {:fn-name "pexpireat", :cluster-key-idx 1, :fn-params-more [key unix-time-milliseconds & args], :fn-params-fixed [key unix-time-milliseconds], :req-args-fixed ["PEXPIREAT" key unix-time-milliseconds], :fn-docstring "Set the expiration for a key as a UNIX timestamp specified in milliseconds.\n\nPEXPIREAT key unix-time-milliseconds [condition]\n\nAvailable since: 2.6.0.\n\nTime complexity: O(1)"}
"PEXPIRETIME" {:fn-name "pexpiretime", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["PEXPIRETIME" key], :fn-docstring "Get the expiration Unix timestamp for a key in milliseconds.\n\nPEXPIRETIME key\n\nAvailable since: 7.0.0.\n\nTime complexity: O(1)"}
"PFADD" {:fn-name "pfadd", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["PFADD" key], :fn-docstring "Adds the specified elements to the specified HyperLogLog..\n\nPFADD key [element [element ...]]\n\nAvailable since: 2.8.9.\n\nTime complexity: O(1) to add every element."}
"PFCOUNT" {:fn-name "pfcount", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["PFCOUNT" key], :fn-docstring "Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s)..\n\nPFCOUNT key [key ...]\n\nAvailable since: 2.8.9.\n\nTime complexity: O(1) with a very small average constant time when called with a single key. O(N) with N being the number of keys, and much bigger constant times, when called with multiple keys."}
"PFDEBUG" {:fn-name "pfdebug", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [subcommand key], :req-args-fixed ["PFDEBUG" subcommand key], :fn-docstring "Internal commands for debugging HyperLogLog values.\n\nPFDEBUG subcommand key\n\nAvailable since: 2.8.9.\n\nTime complexity: N/A"}
"PFMERGE" {:fn-name "pfmerge", :cluster-key-idx 1, :fn-params-more [destkey sourcekey & args], :fn-params-fixed [destkey sourcekey], :req-args-fixed ["PFMERGE" destkey sourcekey], :fn-docstring "Merge N different HyperLogLogs into a single one..\n\nPFMERGE destkey sourcekey [sourcekey ...]\n\nAvailable since: 2.8.9.\n\nTime complexity: O(N) to merge N HyperLogLogs, but with high constant times."}
"PFSELFTEST" {:fn-name "pfselftest", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["PFSELFTEST"], :fn-docstring "An internal command for testing HyperLogLog values.\n\nPFSELFTEST \n\nAvailable since: 2.8.9.\n\nTime complexity: N/A"}
"PING" {:fn-name "ping", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["PING"], :fn-docstring "Ping the server.\n\nPING [message]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"PSETEX" {:fn-name "psetex", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key milliseconds value], :req-args-fixed ["PSETEX" key milliseconds value], :fn-docstring "Set the value and expiration in milliseconds of a key.\n\nPSETEX key milliseconds value\n\nAvailable since: 2.6.0.\n\nTime complexity: O(1)"}
"PSUBSCRIBE" {:fn-name "psubscribe", :cluster-key-idx 1, :fn-params-more [pattern & args], :fn-params-fixed [pattern], :req-args-fixed ["PSUBSCRIBE" pattern], :fn-docstring "Listen for messages published to channels matching the given patterns.\n\nPSUBSCRIBE pattern [pattern ...]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the number of patterns the client is already subscribed to."}
"PSYNC" {:fn-name "psync", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [replicationid offset], :req-args-fixed ["PSYNC" replicationid offset], :fn-docstring "Internal command used for replication.\n\nPSYNC replicationid offset\n\nAvailable since: 2.8.0.\n\n"}
"PTTL" {:fn-name "pttl", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["PTTL" key], :fn-docstring "Get the time to live for a key in milliseconds.\n\nPTTL key\n\nAvailable since: 2.6.0.\n\nTime complexity: O(1)"}
"PUBLISH" {:fn-name "publish", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [channel message], :req-args-fixed ["PUBLISH" channel message], :fn-docstring "Post a message to a channel.\n\nPUBLISH channel message\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client)."}
"PUBSUB" {:fn-name "pubsub", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["PUBSUB"], :fn-docstring "A container for Pub/Sub commands.\n\nPUBSUB \n\nAvailable since: 2.8.0.\n\nTime complexity: Depends on subcommand."}
"PUBSUB CHANNELS" {:fn-name "pubsub-channels", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["PUBSUB" "CHANNELS"], :fn-docstring "List active channels.\n\nPUBSUB CHANNELS [pattern]\n\nAvailable since: 2.8.0.\n\nTime complexity: O(N) where N is the number of active channels, and assuming constant time pattern matching (relatively short channels and patterns)"}
"PUBSUB HELP" {:fn-name "pubsub-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["PUBSUB" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nPUBSUB HELP \n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"PUBSUB NUMPAT" {:fn-name "pubsub-numpat", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["PUBSUB" "NUMPAT"], :fn-docstring "Get the count of unique patterns pattern subscriptions.\n\nPUBSUB NUMPAT \n\nAvailable since: 2.8.0.\n\nTime complexity: O(1)"}
"PUBSUB NUMSUB" {:fn-name "pubsub-numsub", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["PUBSUB" "NUMSUB"], :fn-docstring "Get the count of subscribers for channels.\n\nPUBSUB NUMSUB [channel [channel ...]]\n\nAvailable since: 2.8.0.\n\nTime complexity: O(N) for the NUMSUB subcommand, where N is the number of requested channels"}
"PUBSUB SHARDCHANNELS" {:fn-name "pubsub-shardchannels", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["PUBSUB" "SHARDCHANNELS"], :fn-docstring "List active shard channels.\n\nPUBSUB SHARDCHANNELS [pattern]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of active shard channels, and assuming constant time pattern matching (relatively short shard channels)."}
"PUBSUB SHARDNUMSUB" {:fn-name "pubsub-shardnumsub", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["PUBSUB" "SHARDNUMSUB"], :fn-docstring "Get the count of subscribers for shard channels.\n\nPUBSUB SHARDNUMSUB [shardchannel [shardchannel ...]]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) for the SHARDNUMSUB subcommand, where N is the number of requested shard channels"}
"PUNSUBSCRIBE" {:fn-name "punsubscribe", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["PUNSUBSCRIBE"], :fn-docstring "Stop listening for messages posted to channels matching the given patterns.\n\nPUNSUBSCRIBE [pattern [pattern ...]]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N+M) where N is the number of patterns the client is already subscribed and M is the number of total patterns subscribed in the system (by any client)."}
"QUIT" {:fn-name "quit", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["QUIT"], :fn-docstring "Close the connection.\n\nQUIT \n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"RANDOMKEY" {:fn-name "randomkey", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["RANDOMKEY"], :fn-docstring "Return a random key from the keyspace.\n\nRANDOMKEY \n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"READONLY" {:fn-name "readonly", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["READONLY"], :fn-docstring "Enables read queries for a connection to a cluster replica node.\n\nREADONLY \n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"READWRITE" {:fn-name "readwrite", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["READWRITE"], :fn-docstring "Disables read queries for a connection to a cluster replica node.\n\nREADWRITE \n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"RENAME" {:fn-name "rename", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key newkey], :req-args-fixed ["RENAME" key newkey], :fn-docstring "Rename a key.\n\nRENAME key newkey\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"RENAMENX" {:fn-name "renamenx", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key newkey], :req-args-fixed ["RENAMENX" key newkey], :fn-docstring "Rename a key, only if the new key does not exist.\n\nRENAMENX key newkey\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"REPLCONF" {:fn-name "replconf", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["REPLCONF"], :fn-docstring "An internal command for configuring the replication stream.\n\nREPLCONF \n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"REPLICAOF" {:fn-name "replicaof", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [host port], :req-args-fixed ["REPLICAOF" host port], :fn-docstring "Make the server a replica of another instance, or promote it as master..\n\nREPLICAOF host port\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"RESET" {:fn-name "reset", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["RESET"], :fn-docstring "Reset the connection.\n\nRESET \n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"RESTORE" {:fn-name "restore", :cluster-key-idx 1, :fn-params-more [key ttl serialized-value & args], :fn-params-fixed [key ttl serialized-value], :req-args-fixed ["RESTORE" key ttl serialized-value], :fn-docstring "Create a key using the provided serialized value, previously obtained using DUMP..\n\nRESTORE key ttl serialized-value [replace] [absttl] [seconds] [frequency]\n\nAvailable since: 2.6.0.\n\nTime complexity: O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N))."}
"RESTORE-ASKING" {:fn-name "restore-asking", :cluster-key-idx 1, :fn-params-more [key ttl serialized-value & args], :fn-params-fixed [key ttl serialized-value], :req-args-fixed ["RESTORE-ASKING" key ttl serialized-value], :fn-docstring "An internal command for migrating keys in a cluster.\n\nRESTORE-ASKING key ttl serialized-value [replace] [absttl] [seconds] [frequency]\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N))."}
"ROLE" {:fn-name "role", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["ROLE"], :fn-docstring "Return the role of the instance in the context of replication.\n\nROLE \n\nAvailable since: 2.8.12.\n\nTime complexity: O(1)"}
"RPOP" {:fn-name "rpop", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["RPOP" key], :fn-docstring "Remove and get the last elements in a list.\n\nRPOP key [count]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of elements returned"}
"RPOPLPUSH" {:fn-name "rpoplpush", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [source destination], :req-args-fixed ["RPOPLPUSH" source destination], :fn-docstring "Remove the last element in a list, prepend it to another list and return it.\n\nRPOPLPUSH source destination\n\nAvailable since: 1.2.0.\n\nTime complexity: O(1)"}
"RPUSH" {:fn-name "rpush", :cluster-key-idx 1, :fn-params-more [key element & args], :fn-params-fixed [key element], :req-args-fixed ["RPUSH" key element], :fn-docstring "Append one or multiple elements to a list.\n\nRPUSH key element [element ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments."}
"RPUSHX" {:fn-name "rpushx", :cluster-key-idx 1, :fn-params-more [key element & args], :fn-params-fixed [key element], :req-args-fixed ["RPUSHX" key element], :fn-docstring "Append an element to a list, only if the list exists.\n\nRPUSHX key element [element ...]\n\nAvailable since: 2.2.0.\n\nTime complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments."}
"SADD" {:fn-name "sadd", :cluster-key-idx 1, :fn-params-more [key member & args], :fn-params-fixed [key member], :req-args-fixed ["SADD" key member], :fn-docstring "Add one or more members to a set.\n\nSADD key member [member ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments."}
"SAVE" {:fn-name "save", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["SAVE"], :fn-docstring "Synchronously save the dataset to disk.\n\nSAVE \n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the total number of keys in all databases"}
"SCAN" {:fn-name "scan", :cluster-key-idx 1, :fn-params-more [cursor & args], :fn-params-fixed [cursor], :req-args-fixed ["SCAN" cursor], :fn-docstring "Incrementally iterate the keys space.\n\nSCAN cursor [pattern] [count] [type]\n\nAvailable since: 2.8.0.\n\nTime complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection."}
"SCARD" {:fn-name "scard", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["SCARD" key], :fn-docstring "Get the number of members in a set.\n\nSCARD key\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"SCRIPT" {:fn-name "script", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["SCRIPT"], :fn-docstring "A container for Lua scripts management commands.\n\nSCRIPT \n\nAvailable since: 2.6.0.\n\nTime complexity: Depends on subcommand."}
"SCRIPT DEBUG" {:fn-name "script-debug", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [mode], :req-args-fixed ["SCRIPT" "DEBUG" mode], :fn-docstring "Set the debug mode for executed scripts..\n\nSCRIPT DEBUG mode\n\nAvailable since: 3.2.0.\n\nTime complexity: O(1)"}
"SCRIPT EXISTS" {:fn-name "script-exists", :cluster-key-idx 2, :fn-params-more [sha1 & args], :fn-params-fixed [sha1], :req-args-fixed ["SCRIPT" "EXISTS" sha1], :fn-docstring "Check existence of scripts in the script cache..\n\nSCRIPT EXISTS sha1 [sha1 ...]\n\nAvailable since: 2.6.0.\n\nTime complexity: O(N) with N being the number of scripts to check (so checking a single script is an O(1) operation)."}
"SCRIPT FLUSH" {:fn-name "script-flush", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["SCRIPT" "FLUSH"], :fn-docstring "Remove all the scripts from the script cache..\n\nSCRIPT FLUSH [async]\n\nAvailable since: 2.6.0.\n\nTime complexity: O(N) with N being the number of scripts in cache"}
"SCRIPT HELP" {:fn-name "script-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["SCRIPT" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nSCRIPT HELP \n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"SCRIPT KILL" {:fn-name "script-kill", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["SCRIPT" "KILL"], :fn-docstring "Kill the script currently in execution..\n\nSCRIPT KILL \n\nAvailable since: 2.6.0.\n\nTime complexity: O(1)"}
"SCRIPT LOAD" {:fn-name "script-load", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [script], :req-args-fixed ["SCRIPT" "LOAD" script], :fn-docstring "Load the specified Lua script into the script cache..\n\nSCRIPT LOAD script\n\nAvailable since: 2.6.0.\n\nTime complexity: O(N) with N being the length in bytes of the script body."}
"SDIFF" {:fn-name "sdiff", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["SDIFF" key], :fn-docstring "Subtract multiple sets.\n\nSDIFF key [key ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the total number of elements in all given sets."}
"SDIFFSTORE" {:fn-name "sdiffstore", :cluster-key-idx 1, :fn-params-more [destination key & args], :fn-params-fixed [destination key], :req-args-fixed ["SDIFFSTORE" destination key], :fn-docstring "Subtract multiple sets and store the resulting set in a key.\n\nSDIFFSTORE destination key [key ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the total number of elements in all given sets."}
"SELECT" {:fn-name "select", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [index], :req-args-fixed ["SELECT" index], :fn-docstring "Change the selected database for the current connection.\n\nSELECT index\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"SET" {:fn-name "set", :cluster-key-idx 1, :fn-params-more [key value & args], :fn-params-fixed [key value], :req-args-fixed ["SET" key value], :fn-docstring "Set the string value of a key.\n\nSET key value [condition] [get] [expiration]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"SETBIT" {:fn-name "setbit", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key offset value], :req-args-fixed ["SETBIT" key offset value], :fn-docstring "Sets or clears the bit at offset in the string value stored at key.\n\nSETBIT key offset value\n\nAvailable since: 2.2.0.\n\nTime complexity: O(1)"}
"SETEX" {:fn-name "setex", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key seconds value], :req-args-fixed ["SETEX" key seconds value], :fn-docstring "Set the value and expiration of a key.\n\nSETEX key seconds value\n\nAvailable since: 2.0.0.\n\nTime complexity: O(1)"}
"SETNX" {:fn-name "setnx", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key value], :req-args-fixed ["SETNX" key value], :fn-docstring "Set the value of a key, only if the key does not exist.\n\nSETNX key value\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"SETRANGE" {:fn-name "setrange", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key offset value], :req-args-fixed ["SETRANGE" key offset value], :fn-docstring "Overwrite part of a string at key starting at the specified offset.\n\nSETRANGE key offset value\n\nAvailable since: 2.2.0.\n\nTime complexity: O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument."}
"SHUTDOWN" {:fn-name "shutdown", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["SHUTDOWN"], :fn-docstring "Synchronously save the dataset to disk and then shut down the server.\n\nSHUTDOWN [nosave_save] [now] [force] [abort]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) when saving, where N is the total number of keys in all databases when saving data, otherwise O(1)"}
"SINTER" {:fn-name "sinter", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["SINTER" key], :fn-docstring "Intersect multiple sets.\n\nSINTER key [key ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets."}
"SINTERCARD" {:fn-name "sintercard", :cluster-key-idx 1, :fn-params-more [numkeys key & args], :fn-params-fixed [numkeys key], :req-args-fixed ["SINTERCARD" numkeys key], :fn-docstring "Intersect multiple sets and return the cardinality of the result.\n\nSINTERCARD numkeys key [key ...] [limit]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets."}
"SINTERSTORE" {:fn-name "sinterstore", :cluster-key-idx 1, :fn-params-more [destination key & args], :fn-params-fixed [destination key], :req-args-fixed ["SINTERSTORE" destination key], :fn-docstring "Intersect multiple sets and store the resulting set in a key.\n\nSINTERSTORE destination key [key ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets."}
"SISMEMBER" {:fn-name "sismember", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key member], :req-args-fixed ["SISMEMBER" key member], :fn-docstring "Determine if a given value is a member of a set.\n\nSISMEMBER key member\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"SLAVEOF" {:fn-name "slaveof", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [host port], :req-args-fixed ["SLAVEOF" host port], :fn-docstring "Make the server a replica of another instance, or promote it as master..\n\nSLAVEOF host port\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"SLOWLOG" {:fn-name "slowlog", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["SLOWLOG"], :fn-docstring "A container for slow log commands.\n\nSLOWLOG \n\nAvailable since: 2.2.12.\n\nTime complexity: Depends on subcommand."}
"SLOWLOG GET" {:fn-name "slowlog-get", :cluster-key-idx 2, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["SLOWLOG" "GET"], :fn-docstring "Get the slow log's entries.\n\nSLOWLOG GET [count]\n\nAvailable since: 2.2.12.\n\nTime complexity: O(N) where N is the number of entries returned"}
"SLOWLOG HELP" {:fn-name "slowlog-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["SLOWLOG" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nSLOWLOG HELP \n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"SLOWLOG LEN" {:fn-name "slowlog-len", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["SLOWLOG" "LEN"], :fn-docstring "Get the slow log's length.\n\nSLOWLOG LEN \n\nAvailable since: 2.2.12.\n\nTime complexity: O(1)"}
"SLOWLOG RESET" {:fn-name "slowlog-reset", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["SLOWLOG" "RESET"], :fn-docstring "Clear all entries from the slow log.\n\nSLOWLOG RESET \n\nAvailable since: 2.2.12.\n\nTime complexity: O(N) where N is the number of entries in the slowlog"}
"SMEMBERS" {:fn-name "smembers", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["SMEMBERS" key], :fn-docstring "Get all the members in a set.\n\nSMEMBERS key\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the set cardinality."}
"SMISMEMBER" {:fn-name "smismember", :cluster-key-idx 1, :fn-params-more [key member & args], :fn-params-fixed [key member], :req-args-fixed ["SMISMEMBER" key member], :fn-docstring "Returns the membership associated with the given elements for a set.\n\nSMISMEMBER key member [member ...]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(N) where N is the number of elements being checked for membership"}
"SMOVE" {:fn-name "smove", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [source destination member], :req-args-fixed ["SMOVE" source destination member], :fn-docstring "Move a member from one set to another.\n\nSMOVE source destination member\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"SORT" {:fn-name "sort", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["SORT" key], :fn-docstring "Sort the elements in a list, set or sorted set.\n\nSORT key [pattern] [offset_count] [pattern [pattern ...]] [order] [sorting] [destination]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N)."}
"SORT_RO" {:fn-name "sort_ro", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["SORT_RO" key], :fn-docstring "Sort the elements in a list, set or sorted set. Read-only variant of SORT..\n\nSORT_RO key [pattern] [offset_count] [pattern [pattern ...]] [order] [sorting]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is O(N)."}
"SPOP" {:fn-name "spop", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["SPOP" key], :fn-docstring "Remove and return one or multiple random members from a set.\n\nSPOP key [count]\n\nAvailable since: 1.0.0.\n\nTime complexity: Without the count argument O(1), otherwise O(N) where N is the value of the passed count."}
"SPUBLISH" {:fn-name "spublish", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [shardchannel message], :req-args-fixed ["SPUBLISH" shardchannel message], :fn-docstring "Post a message to a shard channel.\n\nSPUBLISH shardchannel message\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of clients subscribed to the receiving shard channel."}
"SRANDMEMBER" {:fn-name "srandmember", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["SRANDMEMBER" key], :fn-docstring "Get one or multiple random members from a set.\n\nSRANDMEMBER key [count]\n\nAvailable since: 1.0.0.\n\nTime complexity: Without the count argument O(1), otherwise O(N) where N is the absolute value of the passed count."}
"SREM" {:fn-name "srem", :cluster-key-idx 1, :fn-params-more [key member & args], :fn-params-fixed [key member], :req-args-fixed ["SREM" key member], :fn-docstring "Remove one or more members from a set.\n\nSREM key member [member ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the number of members to be removed."}
"SSCAN" {:fn-name "sscan", :cluster-key-idx 1, :fn-params-more [key cursor & args], :fn-params-fixed [key cursor], :req-args-fixed ["SSCAN" key cursor], :fn-docstring "Incrementally iterate Set elements.\n\nSSCAN key cursor [pattern] [count]\n\nAvailable since: 2.8.0.\n\nTime complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.."}
"SSUBSCRIBE" {:fn-name "ssubscribe", :cluster-key-idx 1, :fn-params-more [shardchannel & args], :fn-params-fixed [shardchannel], :req-args-fixed ["SSUBSCRIBE" shardchannel], :fn-docstring "Listen for messages published to the given shard channels.\n\nSSUBSCRIBE shardchannel [shardchannel ...]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of shard channels to subscribe to."}
"STRLEN" {:fn-name "strlen", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["STRLEN" key], :fn-docstring "Get the length of the value stored in a key.\n\nSTRLEN key\n\nAvailable since: 2.2.0.\n\nTime complexity: O(1)"}
"SUBSCRIBE" {:fn-name "subscribe", :cluster-key-idx 1, :fn-params-more [channel & args], :fn-params-fixed [channel], :req-args-fixed ["SUBSCRIBE" channel], :fn-docstring "Listen for messages published to the given channels.\n\nSUBSCRIBE channel [channel ...]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the number of channels to subscribe to."}
"SUBSTR" {:fn-name "substr", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key start end], :req-args-fixed ["SUBSTR" key start end], :fn-docstring "Get a substring of the string stored at a key.\n\nSUBSTR key start end\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings."}
"SUNION" {:fn-name "sunion", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["SUNION" key], :fn-docstring "Add multiple sets.\n\nSUNION key [key ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the total number of elements in all given sets."}
"SUNIONSTORE" {:fn-name "sunionstore", :cluster-key-idx 1, :fn-params-more [destination key & args], :fn-params-fixed [destination key], :req-args-fixed ["SUNIONSTORE" destination key], :fn-docstring "Add multiple sets and store the resulting set in a key.\n\nSUNIONSTORE destination key [key ...]\n\nAvailable since: 1.0.0.\n\nTime complexity: O(N) where N is the total number of elements in all given sets."}
"SUNSUBSCRIBE" {:fn-name "sunsubscribe", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["SUNSUBSCRIBE"], :fn-docstring "Stop listening for messages posted to the given shard channels.\n\nSUNSUBSCRIBE [shardchannel [shardchannel ...]]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N) where N is the number of clients already subscribed to a shard channel."}
"SWAPDB" {:fn-name "swapdb", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [index1 index2], :req-args-fixed ["SWAPDB" index1 index2], :fn-docstring "Swaps two Redis databases.\n\nSWAPDB index1 index2\n\nAvailable since: 4.0.0.\n\nTime complexity: O(N) where N is the count of clients watching or blocking on keys from both databases."}
"SYNC" {:fn-name "sync", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["SYNC"], :fn-docstring "Internal command used for replication.\n\nSYNC \n\nAvailable since: 1.0.0.\n\n"}
"TIME" {:fn-name "time", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["TIME"], :fn-docstring "Return the current server time.\n\nTIME \n\nAvailable since: 2.6.0.\n\nTime complexity: O(1)"}
"TOUCH" {:fn-name "touch", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["TOUCH" key], :fn-docstring "Alters the last access time of a key(s). Returns the number of existing keys specified..\n\nTOUCH key [key ...]\n\nAvailable since: 3.2.1.\n\nTime complexity: O(N) where N is the number of keys that will be touched."}
"TTL" {:fn-name "ttl", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["TTL" key], :fn-docstring "Get the time to live for a key in seconds.\n\nTTL key\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"TYPE" {:fn-name "type", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["TYPE" key], :fn-docstring "Determine the type stored at key.\n\nTYPE key\n\nAvailable since: 1.0.0.\n\nTime complexity: O(1)"}
"UNLINK" {:fn-name "unlink", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["UNLINK" key], :fn-docstring "Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking..\n\nUNLINK key [key ...]\n\nAvailable since: 4.0.0.\n\nTime complexity: O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of."}
"UNSUBSCRIBE" {:fn-name "unsubscribe", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["UNSUBSCRIBE"], :fn-docstring "Stop listening for messages posted to the given channels.\n\nUNSUBSCRIBE [channel [channel ...]]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N) where N is the number of clients already subscribed to a channel."}
"UNWATCH" {:fn-name "unwatch", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["UNWATCH"], :fn-docstring "Forget about all watched keys.\n\nUNWATCH \n\nAvailable since: 2.2.0.\n\nTime complexity: O(1)"}
"WAIT" {:fn-name "wait", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [numreplicas timeout], :req-args-fixed ["WAIT" numreplicas timeout], :fn-docstring "Wait for the synchronous replication of all the write commands sent in the context of the current connection.\n\nWAIT numreplicas timeout\n\nAvailable since: 3.0.0.\n\nTime complexity: O(1)"}
"WATCH" {:fn-name "watch", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["WATCH" key], :fn-docstring "Watch the given keys to determine execution of the MULTI/EXEC block.\n\nWATCH key [key ...]\n\nAvailable since: 2.2.0.\n\nTime complexity: O(1) for every key."}
"XACK" {:fn-name "xack", :cluster-key-idx 1, :fn-params-more [key group id & args], :fn-params-fixed [key group id], :req-args-fixed ["XACK" key group id], :fn-docstring "Marks a pending message as correctly processed, effectively removing it from the pending entries list of the consumer group. Return value of the command is the number of messages successfully acknowledged, that is, the IDs we were actually able to resolve in the PEL..\n\nXACK key group id [id ...]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1) for each message ID processed."}
"XADD" {:fn-name "xadd", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["XADD" key], :fn-docstring "Appends a new entry to a stream.\n\nXADD key [nomkstream] [trim] id_or_auto field_value [field_value ...]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1) when adding a new entry, O(N) when trimming where N being the number of entries evicted."}
"XAUTOCLAIM" {:fn-name "xautoclaim", :cluster-key-idx 1, :fn-params-more [key group consumer min-idle-time start & args], :fn-params-fixed [key group consumer min-idle-time start], :req-args-fixed ["XAUTOCLAIM" key group consumer min-idle-time start], :fn-docstring "Changes (or acquires) ownership of messages in a consumer group, as if the messages were delivered to the specified consumer..\n\nXAUTOCLAIM key group consumer min-idle-time start [count] [justid]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(1) if COUNT is small."}
"XCLAIM" {:fn-name "xclaim", :cluster-key-idx 1, :fn-params-more [key group consumer min-idle-time id & args], :fn-params-fixed [key group consumer min-idle-time id], :req-args-fixed ["XCLAIM" key group consumer min-idle-time id], :fn-docstring "Changes (or acquires) ownership of a message in a consumer group, as if the message was delivered to the specified consumer..\n\nXCLAIM key group consumer min-idle-time id [id ...] [ms] [unix-time-milliseconds] [count] [force] [justid]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(log N) with N being the number of messages in the PEL of the consumer group."}
"XDEL" {:fn-name "xdel", :cluster-key-idx 1, :fn-params-more [key id & args], :fn-params-fixed [key id], :req-args-fixed ["XDEL" key id], :fn-docstring "Removes the specified entries from the stream. Returns the number of items actually deleted, that may be different from the number of IDs passed in case certain IDs do not exist..\n\nXDEL key id [id ...]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1) for each single item to delete in the stream, regardless of the stream size."}
"XGROUP" {:fn-name "xgroup", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["XGROUP"], :fn-docstring "A container for consumer groups commands.\n\nXGROUP \n\nAvailable since: 5.0.0.\n\nTime complexity: Depends on subcommand."}
"XGROUP CREATE" {:fn-name "xgroup-create", :cluster-key-idx 2, :fn-params-more [key groupname id & args], :fn-params-fixed [key groupname id], :req-args-fixed ["XGROUP" "CREATE" key groupname id], :fn-docstring "Create a consumer group..\n\nXGROUP CREATE key groupname id [mkstream] [entries_read]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XGROUP CREATECONSUMER" {:fn-name "xgroup-createconsumer", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key groupname consumername], :req-args-fixed ["XGROUP" "CREATECONSUMER" key groupname consumername], :fn-docstring "Create a consumer in a consumer group..\n\nXGROUP CREATECONSUMER key groupname consumername\n\nAvailable since: 6.2.0.\n\nTime complexity: O(1)"}
"XGROUP DELCONSUMER" {:fn-name "xgroup-delconsumer", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key groupname consumername], :req-args-fixed ["XGROUP" "DELCONSUMER" key groupname consumername], :fn-docstring "Delete a consumer from a consumer group..\n\nXGROUP DELCONSUMER key groupname consumername\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XGROUP DESTROY" {:fn-name "xgroup-destroy", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key groupname], :req-args-fixed ["XGROUP" "DESTROY" key groupname], :fn-docstring "Destroy a consumer group..\n\nXGROUP DESTROY key groupname\n\nAvailable since: 5.0.0.\n\nTime complexity: O(N) where N is the number of entries in the group's pending entries list (PEL)."}
"XGROUP HELP" {:fn-name "xgroup-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["XGROUP" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nXGROUP HELP \n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XGROUP SETID" {:fn-name "xgroup-setid", :cluster-key-idx 2, :fn-params-more [key groupname id & args], :fn-params-fixed [key groupname id], :req-args-fixed ["XGROUP" "SETID" key groupname id], :fn-docstring "Set a consumer group to an arbitrary last delivered ID value..\n\nXGROUP SETID key groupname id [entries_read]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XINFO" {:fn-name "xinfo", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["XINFO"], :fn-docstring "A container for stream introspection commands.\n\nXINFO \n\nAvailable since: 5.0.0.\n\nTime complexity: Depends on subcommand."}
"XINFO CONSUMERS" {:fn-name "xinfo-consumers", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key groupname], :req-args-fixed ["XINFO" "CONSUMERS" key groupname], :fn-docstring "List the consumers in a consumer group.\n\nXINFO CONSUMERS key groupname\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XINFO GROUPS" {:fn-name "xinfo-groups", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["XINFO" "GROUPS" key], :fn-docstring "List the consumer groups of a stream.\n\nXINFO GROUPS key\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XINFO HELP" {:fn-name "xinfo-help", :cluster-key-idx 2, :fn-params-more nil, :fn-params-fixed [], :req-args-fixed ["XINFO" "HELP"], :fn-docstring "Show helpful text about the different subcommands.\n\nXINFO HELP \n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XINFO STREAM" {:fn-name "xinfo-stream", :cluster-key-idx 2, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["XINFO" "STREAM" key], :fn-docstring "Get information about a stream.\n\nXINFO STREAM key [full]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XLEN" {:fn-name "xlen", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["XLEN" key], :fn-docstring "Return the number of entries in a stream.\n\nXLEN key\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XPENDING" {:fn-name "xpending", :cluster-key-idx 1, :fn-params-more [key group & args], :fn-params-fixed [key group], :req-args-fixed ["XPENDING" key group], :fn-docstring "Return information and entries from a stream consumer group pending entries list, that are messages fetched but never acknowledged..\n\nXPENDING key group [filters]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). O(M), where M is the total number of entries scanned when used with the IDLE filter. When the command returns just the summary and the list of consumers is small, it runs in O(1) time; otherwise, an additional O(N) time for iterating every consumer."}
"XRANGE" {:fn-name "xrange", :cluster-key-idx 1, :fn-params-more [key start end & args], :fn-params-fixed [key start end], :req-args-fixed ["XRANGE" key start end], :fn-docstring "Return a range of elements in a stream, with IDs matching the specified IDs interval.\n\nXRANGE key start end [count]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1)."}
"XREAD" {:fn-name "xread", :cluster-key-idx 1, :fn-params-more [& args], :fn-params-fixed [], :req-args-fixed ["XREAD"], :fn-docstring "Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block..\n\nXREAD [count] [milliseconds] streams\n\nAvailable since: 5.0.0.\n\nTime complexity: For each stream mentioned: O(N) with N being the number of elements being returned, it means that XREAD-ing with a fixed COUNT is O(1). Note that when the BLOCK option is used, XADD will pay O(M) time in order to serve the M clients blocked on the stream getting new data."}
"XREADGROUP" {:fn-name "xreadgroup", :cluster-key-idx 1, :fn-params-more [group_consumer & args], :fn-params-fixed [group_consumer], :req-args-fixed ["XREADGROUP" group_consumer], :fn-docstring "Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block..\n\nXREADGROUP group_consumer [count] [milliseconds] [noack] streams\n\nAvailable since: 5.0.0.\n\nTime complexity: For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data."}
"XREVRANGE" {:fn-name "xrevrange", :cluster-key-idx 1, :fn-params-more [key end start & args], :fn-params-fixed [key end start], :req-args-fixed ["XREVRANGE" key end start], :fn-docstring "Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE.\n\nXREVRANGE key end start [count]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1)."}
"XSETID" {:fn-name "xsetid", :cluster-key-idx 1, :fn-params-more [key last-id & args], :fn-params-fixed [key last-id], :req-args-fixed ["XSETID" key last-id], :fn-docstring "An internal command for replicating stream values.\n\nXSETID key last-id [entries_added] [max_deleted_entry_id]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(1)"}
"XTRIM" {:fn-name "xtrim", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key trim], :req-args-fixed ["XTRIM" key trim], :fn-docstring "Trims the stream to (approximately if '~' is passed) a certain size.\n\nXTRIM key trim\n\nAvailable since: 5.0.0.\n\nTime complexity: O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation."}
"ZADD" {:fn-name "zadd", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["ZADD" key], :fn-docstring "Add one or more members to a sorted set, or update its score if it already exists.\n\nZADD key [condition] [comparison] [change] [increment] score_member [score_member ...]\n\nAvailable since: 1.2.0.\n\nTime complexity: O(log(N)) for each item added, where N is the number of elements in the sorted set."}
"ZCARD" {:fn-name "zcard", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key], :req-args-fixed ["ZCARD" key], :fn-docstring "Get the number of members in a sorted set.\n\nZCARD key\n\nAvailable since: 1.2.0.\n\nTime complexity: O(1)"}
"ZCOUNT" {:fn-name "zcount", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key min max], :req-args-fixed ["ZCOUNT" key min max], :fn-docstring "Count the members in a sorted set with scores within the given values.\n\nZCOUNT key min max\n\nAvailable since: 2.0.0.\n\nTime complexity: O(log(N)) with N being the number of elements in the sorted set."}
"ZDIFF" {:fn-name "zdiff", :cluster-key-idx 1, :fn-params-more [numkeys key & args], :fn-params-fixed [numkeys key], :req-args-fixed ["ZDIFF" numkeys key], :fn-docstring "Subtract multiple sorted sets.\n\nZDIFF numkeys key [key ...] [withscores]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(L + (N-K)log(N)) worst case where L is the total number of elements in all the sets, N is the size of the first set, and K is the size of the result set."}
"ZDIFFSTORE" {:fn-name "zdiffstore", :cluster-key-idx 1, :fn-params-more [destination numkeys key & args], :fn-params-fixed [destination numkeys key], :req-args-fixed ["ZDIFFSTORE" destination numkeys key], :fn-docstring "Subtract multiple sorted sets and store the resulting sorted set in a new key.\n\nZDIFFSTORE destination numkeys key [key ...]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(L + (N-K)log(N)) worst case where L is the total number of elements in all the sets, N is the size of the first set, and K is the size of the result set."}
"ZINCRBY" {:fn-name "zincrby", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key increment member], :req-args-fixed ["ZINCRBY" key increment member], :fn-docstring "Increment the score of a member in a sorted set.\n\nZINCRBY key increment member\n\nAvailable since: 1.2.0.\n\nTime complexity: O(log(N)) where N is the number of elements in the sorted set."}
"ZINTER" {:fn-name "zinter", :cluster-key-idx 1, :fn-params-more [numkeys key & args], :fn-params-fixed [numkeys key], :req-args-fixed ["ZINTER" numkeys key], :fn-docstring "Intersect multiple sorted sets.\n\nZINTER numkeys key [key ...] [weight [weight ...]] [aggregate] [withscores]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set."}
"ZINTERCARD" {:fn-name "zintercard", :cluster-key-idx 1, :fn-params-more [numkeys key & args], :fn-params-fixed [numkeys key], :req-args-fixed ["ZINTERCARD" numkeys key], :fn-docstring "Intersect multiple sorted sets and return the cardinality of the result.\n\nZINTERCARD numkeys key [key ...] [limit]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(N*K) worst case with N being the smallest input sorted set, K being the number of input sorted sets."}
"ZINTERSTORE" {:fn-name "zinterstore", :cluster-key-idx 1, :fn-params-more [destination numkeys key & args], :fn-params-fixed [destination numkeys key], :req-args-fixed ["ZINTERSTORE" destination numkeys key], :fn-docstring "Intersect multiple sorted sets and store the resulting sorted set in a new key.\n\nZINTERSTORE destination numkeys key [key ...] [weight [weight ...]] [aggregate]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set."}
"ZLEXCOUNT" {:fn-name "zlexcount", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key min max], :req-args-fixed ["ZLEXCOUNT" key min max], :fn-docstring "Count the number of members in a sorted set between a given lexicographical range.\n\nZLEXCOUNT key min max\n\nAvailable since: 2.8.9.\n\nTime complexity: O(log(N)) with N being the number of elements in the sorted set."}
"ZMPOP" {:fn-name "zmpop", :cluster-key-idx 1, :fn-params-more [numkeys key & args], :fn-params-fixed [numkeys key], :req-args-fixed ["ZMPOP" numkeys key], :fn-docstring "Remove and return members with scores in a sorted set.\n\nZMPOP numkeys key [key ...] where [count]\n\nAvailable since: 7.0.0.\n\nTime complexity: O(K) + O(N*log(M)) where K is the number of provided keys, N being the number of elements in the sorted set, and M being the number of elements popped."}
"ZMSCORE" {:fn-name "zmscore", :cluster-key-idx 1, :fn-params-more [key member & args], :fn-params-fixed [key member], :req-args-fixed ["ZMSCORE" key member], :fn-docstring "Get the score associated with the given members in a sorted set.\n\nZMSCORE key member [member ...]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(N) where N is the number of members being requested."}
"ZPOPMAX" {:fn-name "zpopmax", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["ZPOPMAX" key], :fn-docstring "Remove and return members with the highest scores in a sorted set.\n\nZPOPMAX key [count]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped."}
"ZPOPMIN" {:fn-name "zpopmin", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["ZPOPMIN" key], :fn-docstring "Remove and return members with the lowest scores in a sorted set.\n\nZPOPMIN key [count]\n\nAvailable since: 5.0.0.\n\nTime complexity: O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped."}
"ZRANDMEMBER" {:fn-name "zrandmember", :cluster-key-idx 1, :fn-params-more [key & args], :fn-params-fixed [key], :req-args-fixed ["ZRANDMEMBER" key], :fn-docstring "Get one or multiple random elements from a sorted set.\n\nZRANDMEMBER key [options]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(N) where N is the number of elements returned"}
"ZRANGE" {:fn-name "zrange", :cluster-key-idx 1, :fn-params-more [key start stop & args], :fn-params-fixed [key start stop], :req-args-fixed ["ZRANGE" key start stop], :fn-docstring "Return a range of members in a sorted set.\n\nZRANGE key start stop [sortby] [rev] [offset_count] [withscores]\n\nAvailable since: 1.2.0.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned."}
"ZRANGEBYLEX" {:fn-name "zrangebylex", :cluster-key-idx 1, :fn-params-more [key min max & args], :fn-params-fixed [key min max], :req-args-fixed ["ZRANGEBYLEX" key min max], :fn-docstring "Return a range of members in a sorted set, by lexicographical range.\n\nZRANGEBYLEX key min max [offset_count]\n\nAvailable since: 2.8.9.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N))."}
"ZRANGEBYSCORE" {:fn-name "zrangebyscore", :cluster-key-idx 1, :fn-params-more [key min max & args], :fn-params-fixed [key min max], :req-args-fixed ["ZRANGEBYSCORE" key min max], :fn-docstring "Return a range of members in a sorted set, by score.\n\nZRANGEBYSCORE key min max [withscores] [offset_count]\n\nAvailable since: 1.0.5.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N))."}
"ZRANGESTORE" {:fn-name "zrangestore", :cluster-key-idx 1, :fn-params-more [dst src min max & args], :fn-params-fixed [dst src min max], :req-args-fixed ["ZRANGESTORE" dst src min max], :fn-docstring "Store a range of members from sorted set into another key.\n\nZRANGESTORE dst src min max [sortby] [rev] [offset_count]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements stored into the destination key."}
"ZRANK" {:fn-name "zrank", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key member], :req-args-fixed ["ZRANK" key member], :fn-docstring "Determine the index of a member in a sorted set.\n\nZRANK key member\n\nAvailable since: 2.0.0.\n\nTime complexity: O(log(N))"}
"ZREM" {:fn-name "zrem", :cluster-key-idx 1, :fn-params-more [key member & args], :fn-params-fixed [key member], :req-args-fixed ["ZREM" key member], :fn-docstring "Remove one or more members from a sorted set.\n\nZREM key member [member ...]\n\nAvailable since: 1.2.0.\n\nTime complexity: O(M*log(N)) with N being the number of elements in the sorted set and M the number of elements to be removed."}
"ZREMRANGEBYLEX" {:fn-name "zremrangebylex", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key min max], :req-args-fixed ["ZREMRANGEBYLEX" key min max], :fn-docstring "Remove all members in a sorted set between the given lexicographical range.\n\nZREMRANGEBYLEX key min max\n\nAvailable since: 2.8.9.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation."}
"ZREMRANGEBYRANK" {:fn-name "zremrangebyrank", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key start stop], :req-args-fixed ["ZREMRANGEBYRANK" key start stop], :fn-docstring "Remove all members in a sorted set within the given indexes.\n\nZREMRANGEBYRANK key start stop\n\nAvailable since: 2.0.0.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation."}
"ZREMRANGEBYSCORE" {:fn-name "zremrangebyscore", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key min max], :req-args-fixed ["ZREMRANGEBYSCORE" key min max], :fn-docstring "Remove all members in a sorted set within the given scores.\n\nZREMRANGEBYSCORE key min max\n\nAvailable since: 1.2.0.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation."}
"ZREVRANGE" {:fn-name "zrevrange", :cluster-key-idx 1, :fn-params-more [key start stop & args], :fn-params-fixed [key start stop], :req-args-fixed ["ZREVRANGE" key start stop], :fn-docstring "Return a range of members in a sorted set, by index, with scores ordered from high to low.\n\nZREVRANGE key start stop [withscores]\n\nAvailable since: 1.2.0.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned."}
"ZREVRANGEBYLEX" {:fn-name "zrevrangebylex", :cluster-key-idx 1, :fn-params-more [key max min & args], :fn-params-fixed [key max min], :req-args-fixed ["ZREVRANGEBYLEX" key max min], :fn-docstring "Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings..\n\nZREVRANGEBYLEX key max min [offset_count]\n\nAvailable since: 2.8.9.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N))."}
"ZREVRANGEBYSCORE" {:fn-name "zrevrangebyscore", :cluster-key-idx 1, :fn-params-more [key max min & args], :fn-params-fixed [key max min], :req-args-fixed ["ZREVRANGEBYSCORE" key max min], :fn-docstring "Return a range of members in a sorted set, by score, with scores ordered from high to low.\n\nZREVRANGEBYSCORE key max min [withscores] [offset_count]\n\nAvailable since: 2.2.0.\n\nTime complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N))."}
"ZREVRANK" {:fn-name "zrevrank", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key member], :req-args-fixed ["ZREVRANK" key member], :fn-docstring "Determine the index of a member in a sorted set, with scores ordered from high to low.\n\nZREVRANK key member\n\nAvailable since: 2.0.0.\n\nTime complexity: O(log(N))"}
"ZSCAN" {:fn-name "zscan", :cluster-key-idx 1, :fn-params-more [key cursor & args], :fn-params-fixed [key cursor], :req-args-fixed ["ZSCAN" key cursor], :fn-docstring "Incrementally iterate sorted sets elements and associated scores.\n\nZSCAN key cursor [pattern] [count]\n\nAvailable since: 2.8.0.\n\nTime complexity: O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.."}
"ZSCORE" {:fn-name "zscore", :cluster-key-idx 1, :fn-params-more nil, :fn-params-fixed [key member], :req-args-fixed ["ZSCORE" key member], :fn-docstring "Get the score associated with the given member in a sorted set.\n\nZSCORE key member\n\nAvailable since: 1.2.0.\n\nTime complexity: O(1)"}
"ZUNION" {:fn-name "zunion", :cluster-key-idx 1, :fn-params-more [numkeys key & args], :fn-params-fixed [numkeys key], :req-args-fixed ["ZUNION" numkeys key], :fn-docstring "Add multiple sorted sets.\n\nZUNION numkeys key [key ...] [weight [weight ...]] [aggregate] [withscores]\n\nAvailable since: 6.2.0.\n\nTime complexity: O(N)+O(M*log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set."}
"ZUNIONSTORE" {:fn-name "zunionstore", :cluster-key-idx 1, :fn-params-more [destination numkeys key & args], :fn-params-fixed [destination numkeys key], :req-args-fixed ["ZUNIONSTORE" destination numkeys key], :fn-docstring "Add multiple sorted sets and store the resulting sorted set in a new key.\n\nZUNIONSTORE destination numkeys key [key ...] [weight [weight ...]] [aggregate]\n\nAvailable since: 2.0.0.\n\nTime complexity: O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set."}
}